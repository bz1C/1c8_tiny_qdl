&НаКлиенте
Перем кКонстанты;

&НаСервере
Перем сКонстанты;

&НаСервере
Перем сКэшСоответствийОбъекта;

&НаСервере
Перем сКэшДанныхСчета;


#Область ТочкиВхода
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	 РежимОбработки = "Загрузка";
	 ЕстьРегистрСоответствияОбъектов = Метаданные.РегистрыСведений.Найти("ис_СоответствияОбъектовДляЗагрузкиИД") <> Неопределено;
	 
	 ПоискПоСправочникамПоУмолчанию = "Наименование";
	 ПоискПоПланамСчетовПоУмолчанию = "Наименование";
	 ПоискПоПВХПоУмолчанию          = "Наименование";
	 ПоискПоДокументамПоУмолчанию   = "Номер";
	 ПоискПоПредопределеннымЗначениямПоУмолчанию = "Имя";
	 
	 Если ЕстьРегистрСоответствияОбъектов Тогда
		 РеквизитID = Метаданные.РегистрыСведений.ис_СоответствияОбъектовДляЗагрузкиИД.Измерения.Найти("ID");
	 Иначе
		 РеквизитID = Неопределено;
	 КонецЕсли; 
	 Если РеквизитID <> Неопределено Тогда
		 ДлинаID = РеквизитID.Тип.КвалификаторыСтроки.Длина;	 
	 Иначе
		 ДлинаID = 100;
	 КонецЕсли;
 КонецПроцедуры  
 
 &НаКлиенте
Процедура ВыполнитьОбработку(Команда)
	ОчиститьСообщения(); 
	Если не ПроверитьЗаполнениеФормы() Тогда
		Возврат; 
	КонецЕсли;  
	
	Элементы.ГруппаСтраницы.ТекущаяСтраница = Элементы.СтраницаНастройки;
	
	ТаблицаПротокол.Очистить();
	ОстановкаПоОшибке = не Объект.НеОстанавливатьЗагрузкуПоОшибке;
	
	ДанныеФайлов = Новый Массив;
	
	НомерФайла = -1;
	Для Каждого СтрФайл Из СписокФайлов Цикл
		НомерФайла = НомерФайла + 1;
		Если ПустаяСтрока(СтрФайл.Значение) Тогда
			Продолжить; 
		КонецЕсли;
		ОбработкаПрерыванияПользователя();
		
		Описание = СтрШаблон(НСтр("ru='Считывание файла ""%1""...'"), СтрФайл.Значение);
		ДобавитьСобытиеВПротокол("Информация", "Е1", , , , Описание);
		Состояние(Описание, НомерФайла/СписокФайлов.Количество(), НСтр("ru='Открытие и чтение файла Excel'"));
		
		ДанныеФайла = ПрочитатьФайлДляЗагрузки(СтрФайл.Значение); // ШАГ 1
		Если ДанныеФайла = Неопределено Тогда
			Если не ОстановкаПоОшибке Тогда
				Продолжить; 
			Иначе
				Прервать;
			КонецЕсли;
		КонецЕсли;
		
		ДанныеФайлов.Добавить(ДанныеФайла);
	КонецЦикла;
	
	
	Состояние(НСтр("ru='Передача данных из файлов на сервер...'"));
	ДанныеФайловВХ = ПоместитьВоВременноеХранилище(ДанныеФайлов, ЭтаФорма.УникальныйИдентификатор);
	
	// "сборка мусора"
	ДанныеФайла = Неопределено;
	ДанныеФайлов = Неопределено;
	
	Описание = НСтр("ru='Преобразование данных файлов...'");
	Состояние(Описание);
	ДобавитьСобытиеВПротокол("Информация", "Е99", , , , Описание);
	Если ПреобразоватьДанныеФайлов() Тогда // ШАГ 2

		Состояние(НСтр("ru='Загрузка данных...'"));
		Пока ПродолжитьОбработкуФайловСервер() Цикл  // ШАГ 3
			ОбработкаПрерыванияПользователя();
		КонецЦикла; 
		
	КонецЕсли; 
	
	ДобавитьСобытиеВПротокол("Информация", "Е100", , , , НСтр("ru='Обработка завершена.'"));
	Элементы.ГруппаСтраницы.ТекущаяСтраница = Элементы.СтраницаПротокол;
	
КонецПроцедуры

 
#КонецОбласти 

#Область ОбработчикиСобытийФормы

&НаКлиенте
Процедура ВыборФайлов(Команда)
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);	
	ДиалогВыбораФайла.Заголовок          = НСтр("ru = 'Выберите файлы выгрузки'");	
	ДиалогВыбораФайла.МножественныйВыбор = Истина;
	ДиалогВыбораФайла.Фильтр             = "Файлы Excel (*.xlsx)|*.xlsx|Все файлы (*.*)|*.*";
	ДиалогВыбораФайла.Показать(Новый ОписаниеОповещения("ЗавершениеВыбораФайлов", ЭтотОбъект));
КонецПроцедуры                                                               

&НаКлиенте
Процедура ЗавершениеВыбораФайлов(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт		
	Если ВыбранныеФайлы <> Неопределено И ВыбранныеФайлы.Количество() > 0 Тогда
		Для Каждого СтрФайл Из ВыбранныеФайлы Цикл
			СписокФайлов.Добавить(СтрФайл);
		КонецЦикла;
	КонецЕсли;		
КонецПроцедуры

&НаКлиенте
Процедура РежимОбработкиПриИзменении(Элемент)
	//Элементы.ГруппаРегистрацияСоответствий.Видимость = (РежимОбработки = "РегистрацияСоответствий");
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	кКонстанты = ИнициализироватьКонстанты();
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура УстановитьВидимостьДоступностьФормы(Форма)
	Если Форма.Объект.НеОчищатьСодержимоеТабличныхЧастей Тогда
		Форма.Объект.НеОчищатьТЧПриЗагрузкеОбъекта = Истина;
	КонецЕсли; 
	Форма.Элементы.НеОчищатьТЧПриЗагрузкеОбъекта.Доступность = не Форма.Объект.НеОчищатьСодержимоеТабличныхЧастей;
КонецПроцедуры
 

&НаКлиенте
Процедура НеОчищатьСодержимоеТабличныхЧастейПриИзменении(Элемент)
	УстановитьВидимостьДоступностьФормы(ЭтаФорма);
КонецПроцедуры

&НаКлиенте
Процедура ОткрытьРегистрСоответствия(Команда)
	Если ЕстьРегистрСоответствияОбъектов Тогда
		ОткрытьФорму("РегистрСведений.ис_СоответствияОбъектовДляЗагрузкиИД.ФормаСписка"); 
	Иначе
		ПоказатьПредупреждение(, НСтр("ru='Регистр соответствия отсутствует в конфигурации.'")); 
	КонецЕсли; 
КонецПроцедуры

#КонецОбласти 

#Область РаботаСФормой

&НаКлиенте
Функция ПроверитьЗаполнениеФормы()
	Успех = Истина;
	Если НЕ ЗначениеЗаполнено(Объект.Источник) Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Поле  = "Объект.Источник";
		Сообщение.Текст = НСтр("ru='Не заполнен источник'");
		Сообщение.Сообщить();
		Успех = Ложь;
	КонецЕсли;
	
	Если РежимОбработки <> "Загрузка" Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Поле  = "РежимОбработки";
		Сообщение.Текст = НСтр("ru='Данный режим обработки в текущей версии не поддерживается.'");
		Сообщение.Сообщить();
		Успех = Ложь; 
	КонецЕсли; 
	
	Возврат Успех; 
 КонецФункции

	
#КонецОбласти 

#Область РаботаСЭксель

&НаКлиенте
Функция ПрочитатьФайлДляЗагрузки(знач ПутьКФайлу)
	Попытка
		// Загрузка Microsoft Excel
		ExcelПриложение = Новый COMОбъект("Excel.Application");
	Исключение                                               
		ДобавитьСобытиеВПротокол("Ошибка", 2, , , ,ОписаниеОшибки(), РезультатПротокол().Остановка);
		Возврат Неопределено;
	КонецПопытки;
	
	Попытка
		// Открытие файла Microsoft Excel
		ExcelФайл = ExcelПриложение.WorkBooks.Open(ПутьКФайлу);
	Исключение
		ДобавитьСобытиеВПротокол("Ошибка", 3, , , ,ОписаниеОшибки(), РезультатПротокол().Остановка);
		Возврат Неопределено;
	КонецПопытки;
	
	ДанныеФайла = Новый Структура;
	ДанныеФайла.Вставить("ИмяФайла", ПутьКФайлу);
	
#Область ЛистНастройки
	ExcelЛист = ПолучитьЛистЭксель(ExcelПриложение, ExcelФайл, кКонстанты.ЛистНастройки);
	Если ExcelЛист = Неопределено Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	
	ИмяОбъекта = СокрЛП(ExcelЛист.Range(кКонстанты.ИмяТаблицы).Value);
	ИмяТЧ = СокрЛП(ExcelЛист.Range(кКонстанты.ИмяТЧ).Value);
	
	Если ПустаяСтрока(ИмяОбъекта) Тогда
		ДобавитьСобытиеВПротокол(
			"Ошибка", 
			4, , , ,
			СтрШаблон(
				НСтр("ru='В файле ""%1"" на листе ""%2"" не заполнено имя объекта (значение поля ""Имя 1С"").'"),
				ПутьКФайлу,
				кКонстанты.ЛистНастройки),
			РезультатПротокол().Остановка);
		ВыгрузитьЭксель(ExcelПриложение);
		Возврат Неопределено;
	КонецЕсли;
	
	ДанныеФайла.Вставить("ИмяОбъекта", ИмяОбъекта);
	ДанныеФайла.Вставить("ИмяТЧ", ИмяТЧ);
#КонецОбласти 
	
#Область ЛистОписание
		
	ExcelЛист = ПолучитьЛистЭксель(ExcelПриложение, ExcelФайл, кКонстанты.ЛистОписание);
	Если ExcelЛист = Неопределено Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	
	ОбластьКолонка = ПолучитьИменованнуюОбласть(ExcelПриложение, ExcelЛист, ПутьКФайлу, кКонстанты.ЛистОписание, кКонстанты.ОписаниеКолонка);
	Если ОбластьКолонка = Неопределено Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	КолонкаНомерКолонки = ОбластьКолонка.Column;
	
	ОбластьИмя1С = ПолучитьИменованнуюОбласть(ExcelПриложение, ExcelЛист, ПутьКФайлу, кКонстанты.ЛистОписание, кКонстанты.ОписаниеИмя1С);
	Если ОбластьИмя1С = Неопределено Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	Имя1СНомерКолонки = ОбластьИмя1С.Column;
	
	ОбластьПроверкаЗаполнения = ПолучитьИменованнуюОбласть(ExcelПриложение, ExcelЛист, ПутьКФайлу, кКонстанты.ЛистОписание, кКонстанты.ОписаниеПроверкаЗаполнения);
	Если ОбластьПроверкаЗаполнения = Неопределено Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	ПроверкаЗаполненияНомерКолонки = ОбластьПроверкаЗаполнения.Column;
	
	ОбластьОсновнойПоиск = ПолучитьИменованнуюОбласть(ExcelПриложение, ExcelЛист, ПутьКФайлу, кКонстанты.ЛистОписание, кКонстанты.ОписаниеОсновнойПоиск);
	Если ОбластьОсновнойПоиск = Неопределено Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	ОсновнойПоискНомерКолонки = ОбластьОсновнойПоиск.Column;
	
	ОбластьПолеОтбора = ПолучитьИменованнуюОбласть(ExcelПриложение, ExcelЛист, ПутьКФайлу, кКонстанты.ЛистОписание, кКонстанты.ОписаниеПолеОтбора);
	Если ОбластьПолеОтбора = Неопределено Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	ПолеОтбораНомерКолонки = ОбластьПолеОтбора.Column;
	
	НомерСтроки = ОбластьКолонка.Row+ОбластьКолонка.Rows.Count;
	ДанныеФайла.Вставить("ЕОписание", Новый Массив);
	ДанныеФайла.Вставить("ОписаниеНомерПервойСтроки", НомерСтроки);
	
	
	Пока Истина Цикл
		ИмяКолонки = ExcelЛист.Cells(НомерСтроки, КолонкаНомерКолонки).Value;
		
		Если не ЗначениеЗаполнено(ИмяКолонки) Тогда
			Прервать;
		КонецЕсли; 
		
		ДанныеФайла.ЕОписание.Добавить(Новый Структура(
			"ИмяКолонкиДанные, Имя1С, ПроверятьЗаполнение, ОсновнойПоиск, ПолеОтбора",
		    ИмяКолонки, 
			ExcelЛист.Cells(НомерСтроки, Имя1СНомерКолонки).Value,
			ExcelЛист.Cells(НомерСтроки, ПроверкаЗаполненияНомерКолонки).Value,
			ExcelЛист.Cells(НомерСтроки, ОсновнойПоискНомерКолонки).Value,
			ExcelЛист.Cells(НомерСтроки, ПолеОтбораНомерКолонки).Value));
		
		НомерСтроки = НомерСтроки + 1;		
	КонецЦикла;
	
#КонецОбласти 
	
	//СформироватьКолонкиТаблицыДанных();
#Область ЛистДанные
	ExcelЛист = ПолучитьЛистЭксель(ExcelПриложение, ExcelФайл, кКонстанты.ЛистДанные);
	Если ExcelЛист = Неопределено Тогда
		Возврат Неопределено; 
	КонецЕсли; 
	
	ИспользуемыйДиапазон = ExcelЛист.UsedRange;
	ДанныеКолонкаСтрока = ИспользуемыйДиапазон.Value.Выгрузить();
	ДанныеФайла.Вставить("ЕДанные", ДанныеКолонкаСтрока);	
	ДанныеФайла.Вставить("ДанныеНомерПервойСтроки", ИспользуемыйДиапазон.Row+1);
#КонецОбласти 
	
	ВыгрузитьЭксель(ExcelПриложение);
	
	Возврат ДанныеФайла;
КонецФункции

&НаКлиенте
Функция ВыгрузитьЭксель(ExcelПриложение)
	Попытка
		ExcelПриложение.DisplayAlerts = False;
		ExcelПриложение.Quit();
	Исключение
		ДобавитьСобытиеВПротокол(
			"Ошибка", 
			5, , , ,
			СтрШаблон(НСтр("ru='Ошибка при попытке закрытия приложения Excel: %1'"), ОписаниеОшибки()), 
			НСтр("ru='Приложение Excel не выгружено из памяти. Необходимо сделать это вручную. Обработка будет продолжена.'"));
		Возврат Ложь;
	КонецПопытки;
	Возврат Истина; 
КонецФункции 

&НаКлиенте
Функция ПолучитьИменованнуюОбласть(ExcelПриложение, ExcelЛист, знач ПутьКФайлу, Знач ИмяЛиста, знач ИмяОбласти)
	
	Перем ОбластьКолонка;
	
	Область = ExcelЛист.Range(ИмяОбласти);
	Если Область = Неопределено Тогда
		ДобавитьСобытиеВПротокол(
			"Ошибка", 
			6, , , ,
			СтрШаблон(
				НСтр("ru='В файле ""%1"" на листе ""%2"" не найден диапазон с именем ""%3"".'"),
				ПутьКФайлу,
				ИмяЛиста, 
				ИмяОбласти),
			РезультатПротокол().Остановка);
		
		ВыгрузитьЭксель(ExcelПриложение);
		Возврат Неопределено;
	Иначе
		Возврат Область; 
	КонецЕсли;
КонецФункции

&НаКлиенте
Функция ПолучитьЛистЭксель(ExcelПриложение, ExcelФайл, знач ИмяЛиста)
	
	Перем ExcelЛист;
	
	Попытка
		ExcelЛист = ExcelФайл.WorkSheets(ИмяЛиста);
	Исключение        
		ДобавитьСобытиеВПротокол("Ошибка", 7, , , ,ОписаниеОшибки(), РезультатПротокол().Остановка);
		ВыгрузитьЭксель(ExcelПриложение);
		Возврат Неопределено;
	КонецПопытки;
	Возврат ExcelЛист;

КонецФункции
	
#КонецОбласти 

#Область СтруктурыДанных

&НаСервереБезКонтекста
Функция СоздатьСтруктуруТЗДанныхФайлов()
	ТипСтрока = Новый ОписаниеТипов("Строка");
	ТипЧисло = Новый ОписаниеТипов("Число");
	ТипБулево = Новый ОписаниеТипов("Булево");

	ТЗ = Новый ТаблицаЗначений;
	ТЗ.Колонки.Добавить("ИмяФайла", ТипСтрока);
	ТЗ.Колонки.Добавить("ИмяОбъекта", ТипСтрока);
	ТЗ.Колонки.Добавить("ИмяТЧ", ТипСтрока);
	ТЗ.Колонки.Добавить("ТипОбъекта", ТипСтрока);
	ТЗ.Колонки.Добавить("ВидОбъекта", ТипСтрока);
	ТЗ.Колонки.Добавить("мдОбъекта");
	ТЗ.Колонки.Добавить("мдОбъектаИлиТЧ");
	ТЗ.Колонки.Добавить("МенеджерОбъекта");
	ТЗ.Колонки.Добавить("Описание");
	ТЗ.Колонки.Добавить("Данные");
	ТЗ.Колонки.Добавить("ОписаниеНомерПервойСтроки", ТипЧисло);
	ТЗ.Колонки.Добавить("ДанныеНомерПервойСтроки", ТипЧисло);
	ТЗ.Колонки.Добавить("ОбъектныйТип", ТипБулево);
	ТЗ.Колонки.Добавить("КолонкиДанных");
	ТЗ.Колонки.Добавить("ДопСвойства");
	
	
	ТЗ.Индексы.Добавить("ИмяОбъекта");
	Возврат ТЗ; 
КонецФункции
 
&НаСервереБезКонтекста
Функция СоздатьСтруктуруТЗОписание()
	ТипБулево = Новый ОписаниеТипов("Булево");
	ТипСтрока = Новый ОписаниеТипов("Строка");
	ТипЧисло = Новый ОписаниеТипов("Число");
	ТЗ = Новый ТаблицаЗначений;
	ТЗ.Колонки.Добавить("ИмяКолонкиДанные", ТипСтрока);
	ТЗ.Колонки.Добавить("ИмяКолонкиДанные_ВРег", ТипСтрока);
	ТЗ.Колонки.Добавить("Имя1С", ТипСтрока);
	ТЗ.Колонки.Добавить("Имя1С_ВРег", ТипСтрока);
	ТЗ.Колонки.Добавить("ПроверятьЗаполнение", ТипБулево);
	ТЗ.Колонки.Добавить("ОсновнойПоиск");
	ТЗ.Колонки.Добавить("ПолеОтбора", ТипБулево);
	ТЗ.Колонки.Добавить("Тип");
	ТЗ.Колонки.Добавить("ПрисутствуетНаЛистеДанные", ТипБулево);
	ТЗ.Колонки.Добавить("НестандартноеОбращение", ТипБулево);
	ТЗ.Колонки.Добавить("НомерСубконто", ТипЧисло);
	
	ТЗ.Индексы.Добавить("ИмяКолонкиДанные_Врег");
	ТЗ.Индексы.Добавить("Имя1С_ВРег");
	Возврат ТЗ; 
КонецФункции


&НаКлиентеНаСервереБезКонтекста
Функция ИнициализироватьКонстанты()
	Перем Конст;
	Конст = Новый Структура;
	Конст.Вставить("ЛистНастройки", "Настройки");
	
	Конст.Вставить("ЛистОписание",  "Описание");
	Конст.Вставить("ЛистДанные",    "Данные");
	
	Конст.Вставить("ИмяТаблицы", "Имя");
	Конст.Вставить("ИмяТЧ", "ТЧ");
	
	Конст.Вставить("ОписаниеКолонка", "КолонкаДанных");
	Конст.Вставить("ОписаниеИмя1С", "КолонкаИмя");
	Конст.Вставить("ОписаниеПроверкаЗаполнения", "КолонкаПроверкаЗаполнения");
	Конст.Вставить("ОписаниеОсновнойПоиск", "КолонкаОсновнойПоиск");
	Конст.Вставить("ОписаниеПолеОтбора", "КолонкаПолеОтбора");
	
	
	
	//Конст.Вставить("ExcelНастройкиНомерСтрокиИмяТабличнойЧасти", 3);
	//Конст.Вставить("ExcelНастройкиНомерКолонкиИмяТабличнойЧасти", 3);
	//
	//Конст.Вставить("ExcelОписаниеНомерКолонкиИмяКолонки", 1);
	//Конст.Вставить("ExcelОписаниеНомерКолонкиИмяОбъекта", 2);
	//Конст.Вставить("ExcelОписаниеНомерКолонкиПроверкаЗаполнения", 3);
	//Конст.Вставить("ExcelОписаниеНомерКолонкиСинонимОбъекта", 4);
	//Конст.Вставить("ExcelОписаниеНомерКолонкиТипОбъекта", 5);
	//Конст.Вставить("ExcelОписаниеНомерКолонкиДлина", 6);
	//Конст.Вставить("ExcelОписаниеНомерКолонкиТочность", 7);                      
	//Конст.Вставить("ExcelОписаниеНомерКолонкиОсновнойПоиск", 10);
	//Конст.Вставить("ExcelОписаниеНомерКолонкиПолеОтбора", 12);

	//Конст.Вставить("ExcelОписаниеКолонкаID", "ID");                  
	//Конст.Вставить("ExcelОписаниеКолонкаRef", "Ref");
	//Конст.Вставить("ExcelОписаниеКолонкаСсылка", "Ссылка");
	
	//Конст.Вставить("ДанныеID", "ID");                  
	//Конст.Вставить("ДанныеRef", "Ref");
	//Конст.Вставить("ДанныеСсылка", "Ссылка");
	
	
	Возврат Конст; 
КонецФункции

&НаСервереБезКонтекста
Функция СоздатьСтруктуруКэшаСоответствийОбъекта()
	ТЗ = Новый ТаблицаЗначений;
	ТЗ.Колонки.Добавить("Источник");
	ТЗ.Колонки.Добавить("Таблица");
	ТЗ.Колонки.Добавить("ID");
	ТЗ.Колонки.Добавить("СсылкаОбъекта");
	
	ТЗ.Индексы.Добавить("Источник, Таблица, ID");
	
	Возврат ТЗ; 
КонецФункции

#КонецОбласти 

#Область ЯдроОбработки

&НаСервере
Функция ПродолжитьОбработкуФайловСервер()
	ДанныеФайлов = ПолучитьИзВременногоХранилища(ДанныеФайловВХ);	
	УдалитьИзВременногоХранилища(ДанныеФайловВХ);
	
	Если Объект.ИспользоватьТранзакцию и не ТранзакцияАктивна() Тогда
		НачатьТранзакцию();
	КонецЕсли; 
	
	сКэшДанныхСчета = Новый Соответствие;
	
	Для каждого ДанныеФайла Из ДанныеФайлов Цикл
		
		ДобавитьСобытиеВПротоколСервер(
			"Информация",
			"Е119",
			ДанныеФайла.ИмяОбъекта,
			ДанныеФайла.ИмяТЧ,,
			СтрШаблон(НСтр("ru='Загрузка данных файла ""%1""...'"), ДанныеФайла.ИмяФайла)
		);
		
		Если не ЗагрузитьОбъектыИзФайла(ДанныеФайлов, ДанныеФайла) Тогда
			Если не ОстановкаПоОшибке = Ложь Тогда
				Возврат Ложь; 
			КонецЕсли; 
		КонецЕсли; ;
	КонецЦикла; 	
	
	// если будем разбивать на несколько вызовов, фиксация должна происходить в последнем вызове.
	Если Объект.ИспользоватьТранзакцию и ТранзакцияАктивна() Тогда
		ЗафиксироватьТранзакцию();
	КонецЕсли; 

	//ПоместитьВоВременноеХранилище(ДанныеФайловТЗ, ДанныеФайловВХ);
	УдалитьИзВременногоХранилища(ДанныеФайловВХ);	
	Возврат Ложь; 
КонецФункции

&НаСервере
Функция ЗагрузитьОбъектыИзФайла(ДанныеФайлов, ДанныеФайла)
	Если ДанныеФайла.ОбъектныйТип Тогда
		Если ЗначениеЗаполнено(ДанныеФайла.ИмяТЧ) Тогда
			// табличная часть
			Если не ВыполнитьПреобразованиеТиповТаблицыДанных(ДанныеФайлов, ДанныеФайла) Тогда
				Возврат Ложь; 
			КонецЕсли;
			Возврат ЗагрузитьТЧИзФайла(ДанныеФайлов, ДанныеФайла);
		Иначе
			// объектный тип (шапка)
			// 1 строка = 1 объект
			НомерСтроки=-1;
			
			ИмяКолонкиИД = ИмяСистемнойКолонки("ID", ДанныеФайла);
			Если ДанныеФайла.Данные.Колонки.Найти(ИмяКолонкиИД) <> Неопределено Тогда
				ДанныеФайла.ДопСвойства.Вставить("КолонкаИД", ИмяКолонкиИД);
			КонецЕсли;
			ИмяКолонкиРеф = ИмяСистемнойКолонки("Ref", ДанныеФайла);
			Если ДанныеФайла.Данные.Колонки.Найти(ИмяКолонкиРеф) <> Неопределено Тогда
				ДанныеФайла.ДопСвойства.Вставить("КолонкаРеф", ИмяКолонкиРеф);
			КонецЕсли; 
			Для каждого СтрокаДанных Из ДанныеФайла.Данные Цикл
				НомерСтроки = НомерСтроки+1;
				Если не ЗагрузитьОбъект(ДанныеФайлов, ДанныеФайла, СтрокаДанных, НомерСтроки+ДанныеФайла.ДанныеНомерПервойСтроки) Тогда
					Если ОстановкаПоОшибке или ДанныеФайла.ДопСвойства.Свойство("ПропуститьФайл") Тогда
						Возврат Ложь; 
					КонецЕсли; 
				КонецЕсли;
			КонецЦикла; 
		КонецЕсли;
	Иначе
		//!!! Временно, обработать
		ДанныеФайла.Данные.Колонки.Добавить("__Пропустить", Новый ОписаниеТипов("Булево"));
		// необъектный тип - регистры
		Если не ВыполнитьПреобразованиеТиповТаблицыДанных(ДанныеФайлов, ДанныеФайла) Тогда
			Возврат Ложь; 
		КонецЕсли;
		Возврат ЗагрузитьНаборЗаписейИзФайла(ДанныеФайлов, ДанныеФайла);  
	КонецЕсли;
	
	Возврат Истина; 
КонецФункции

&НаСервере
Функция ВыполнитьПреобразованиеТиповТаблицыДанных(ДанныеФайлов, ДанныеФайла)
	// Необходимые проверки наличия колонок и консистентности данных уже выполнена в СформироватьСтруктуруТаблицыДанных()
	// для регистров проверка, что все колонки с отбором присутствуют на листе Данные - проверено ранее 
	// проверка, что для зависимого регистра отбор - только регистратор - сделано ранее
	
	ТЗДанные = ДанныеФайла.Данные;
		
	Контекст = Новый Структура("ДанныеФайлов, ДанныеФайла, СтрокаДанных, НомерСтроки, ИмяКолонки", ДанныеФайлов, ДанныеФайла);
	ДанныеОшибки = Неопределено;
	ЭтоРегистр = ПолучитьАтрибутыРегистра(ДанныеФайла.ТипОбъекта, Неопределено,,,,,);
	НомерСтроки = -1;
	ИмяКолонкиСсылка = ИмяСистемнойКолонки("Ссылка", ДанныеФайла);
	УстанавливатьЗначение = Неопределено;
	Для каждого СтрокаДанных Из ДанныеФайла.Данные Цикл
		НомерСтроки = НомерСтроки + 1;
		
		Если СтрокаДанных.__Обработано = Истина Тогда
			Продолжить;
		КонецЕсли; 
		
		Контекст.СтрокаДанных = СтрокаДанных;
		Контекст.НомерСтроки = НомерСтроки + ДанныеФайла.ДанныеНомерПервойСтроки;
		
		Если ЗначениеЗаполнено(ДанныеФайла.ИмяТЧ) Тогда // для таб. части есть системное поле "Ссылка"
			// Преобразуем значения колонки Ссылка в ссылку
			Контекст.Вставить("ИмяКолонки", "Ссылка");
			КонвертируемоеЗначение = СтрокаДанных[ИмяКолонкиСсылка];
			ЗначениеОтсутствует = Ложь;
			Тип = ТипЗнч(ПредопределенноеЗначение(ДанныеФайла.ИмяОбъекта+".ПустаяСсылка"));
			Результат = ПреобразоватьЗначение(КонвертируемоеЗначение, Тип, "$id", ЗначениеОтсутствует, ДанныеОшибки, Контекст);
			Если ДанныеОшибки = Неопределено и (ЗначениеОтсутствует = Истина или не ЗначениеЗаполнено(Результат)) Тогда
				// пустое значение ссылки
				//TODO: Здесь при отсутствии ссылки в базе можно запустить процесс загрузки самого объекта по ссылке, если он еще не загружен, но есть в файлах.
				Результат = NULL;
				ДанныеОшибки = Новый Структура("Текст, Код, Пропуск",
					НСтр("ru='Значение поля ""Ссылка"" не может быть пустым'"),
					"Е85",
					"СтрокаПропущенаИлиОстановка"
				);		
			КонецЕсли; 
			
			СтрокаДанных[ИмяКолонкиСсылка] = Результат;
		КонецЕсли;
		
		Если ДанныеОшибки <> Неопределено Тогда
			ДанныеОшибки.Вставить("Пропуск", "СтрокаПропущенаИлиОстановка");
			ДобавитьСообщениеВЛогИзСтруктуры(ДанныеОшибки, "Е84", Контекст.ДанныеФайла, Контекст.НомерСтроки, "Ссылка");
			Если ОстановкаПоОшибке Тогда
				Возврат Ложь; 
			КонецЕсли; 
		КонецЕсли;
		
		// преобразуем значения стандартных колонок таблицы данных
		Для каждого элКолонкаДанных Из ДанныеФайла.КолонкиДанных Цикл
			Контекст.Вставить("ИмяКолонки",элКолонкаДанных.Ключ);
			ДанныеОшибки = Неопределено;
			ЗначениеПоля = ПолучитьЗначениеПоля(ДанныеФайла, СтрокаДанных, элКолонкаДанных.Значение, УстанавливатьПустоеЗначениеПриЕгоОтсутствии, УстанавливатьЗначение, ДанныеОшибки, Контекст);
			Если ДанныеОшибки = Неопределено Тогда
				Если Не УстанавливатьЗначение Тогда
					ЗначениеПоля = NULL;
				КонецЕсли; 
				
				СтрокаДанных[элКолонкаДанных.Ключ] = ЗначениеПоля;
			Иначе	// ошибка получения значения поля
				// для регистров проверка, что все значения, по которым устанавливается отбор, заполнены корректно (возможно даже пустым значениями)
				Если ЭтоРегистр и элКолонкаДанных.Значение.ПолеОтбора Тогда
					// ошибка получения значения поля, по которому производится отбор.
					// есть вероятность, что отбор будет установлен некорректно и затрутся какие-то данные.
					// Это неприемлимо, поэтому при такой ошибке мы вынуждены пропустить обработку всего файла.
					//!!! Временно, чисто для регистра РегистрСведений.ИС_СоответствиеСтатейLBиБДР.
					ДанныеОшибки.Вставить("Пропуск", "СтрокаПропущенаИлиОстановка");
					//ДанныеОшибки.Вставить("Пропуск", "ФайлПропущенИлиОстановка");
					ДанныеОшибки.Текст = ДанныеОшибки.Текст + НСтр("ru=' По данной колонке осуществляется отбор набора записей, поэтому корректный отбор не может быть установлен.'");
				КонецЕсли;
				СтрокаДанных[элКолонкаДанных.Ключ] = NULL;
				Пропуск = ПолучитьЗначениеСвойстваСтруктуры(ДанныеОшибки, "Пропуск", "");
				Если СтрНачинаетсяС(Врег(Пропуск), "КОЛОНКАПРОПУЩЕНА") Тогда
					ДобавитьСообщениеВЛогИзСтруктуры(ДанныеОшибки, "Е122", ДанныеФайла, Контекст.НомерСтроки, элКолонкаДанных.Ключ);
					ДанныеОшибки = Неопределено;
					Продолжить;
				Иначе
					// здесь можно было бы пропустить только строки текущего объекта, но это намного сложнее. Если потребуется, в дальнейшем это можно реализовать.
					ДанныеОшибки.Вставить("Пропуск", "СтрокаПропущенаИлиОстановка");
					ДобавитьСообщениеВЛогИзСтруктуры(ДанныеОшибки, "Е87", ДанныеФайла, Контекст.НомерСтроки, элКолонкаДанных.Ключ);
					//ДанныеОшибки.Вставить("Пропуск", "ФайлПропущенИлиОстановка");
					//Возврат Ложь;
					//!!! Временно, чисто для регистра РегистрСведений.ИС_СоответствиеСтатейLBиБДР.
					ДанныеОшибки = Неопределено;
					СтрокаДанных.__Пропустить = Истина;
					Прервать; 
				КонецЕсли;
			КонецЕсли; 		
		КонецЦикла; // по колонкам
	КонецЦикла; 
	
	Возврат Истина; 
КонецФункции

&НаСервере
Функция ЗагрузитьНаборЗаписейИзФайла(ДанныеФайлов, ДанныеФайла)
	
	ТЗДанные = ДанныеФайла.Данные;
	
	// Проставляем номер исходной строки
	ТЗДанные.Колонки.Добавить("__НомерИсходнойСтроки", Новый ОписаниеТипов("Число"));
	сч = 0;
	//!!! Временно, обработать
	МассивУдаления = Новый Массив;	
	Для каждого стр Из ТЗДанные Цикл
		стр.__НомерИсходнойСтроки = ДанныеФайла.ДанныеНомерПервойСтроки + сч;
		сч = сч + 1;
		
		//!!! Временно, обработать
		Если стр.__Пропустить = Истина Тогда
			МассивУдаления.Добавить(стр);
		КонецЕсли;
		//!!! Временно, обработать
	КонецЦикла;
	
	//!!! Временно, обработать
	Для каждого стр Из МассивУдаления Цикл
		ТЗДанные.Удалить(стр);
	КонецЦикла; 
	//!!! Временно, обработать
	
	
	МасКолонкиОтбора = Новый Массив;
	
	Для каждого элКолонка Из ДанныеФайла.КолонкиДанных Цикл
		Если элКолонка.Значение.ПолеОтбора Тогда
			МасКолонкиОтбора.Добавить(элКолонка.Ключ);
		КонецЕсли; 
	КонецЦикла; 
		
	СтрКолонкиОтбора = СтрСоединить(МасКолонкиОтбора, ", ");
	
	ТЗКлючиОтбора = ТЗДанные.Скопировать(,СтрКолонкиОтбора);
	ТЗКлючиОтбора.Свернуть(СтрКолонкиОтбора);
	
	СтруктураКлючиОтбора = Новый Структура(СтрКолонкиОтбора);
	ТЗДанные.Индексы.Добавить(СтрКолонкиОтбора);
	
	Контекст = Новый Структура("ДанныеФайлов, ДанныеФайла, СтрокаДанных, НомерСтроки", ДанныеФайлов, ДанныеФайла);
	ДанныеОшибки = Неопределено;
	
	Для каждого КлючОтбора Из ТЗКлючиОтбора Цикл
		ЗаполнитьЗначенияСвойств(СтруктураКлючиОтбора, КлючОтбора);
		
		СтрокиПоКлючуОтбора = ТЗДанные.НайтиСтроки(СтруктураКлючиОтбора);
		Для каждого стр Из СтрокиПоКлючуОтбора Цикл
			стр.__Обработано = Истина;
		КонецЦикла;
		
		ТЗПоКлючуОтбора = ТЗДанные.Скопировать(СтрокиПоКлючуОтбора);
		ТЗПоКлючуОтбора.Сортировать("__НомерИсходнойСтроки");
		
		НЗ = ДанныеФайла.МенеджерОбъекта.СоздатьНаборЗаписей();
		
		//Устанавливаем отборы
		Для каждого элОтбор Из МасКолонкиОтбора Цикл
			НЗ.Отбор[элОтбор].Установить(КлючОтбора[элОтбор]); 
		КонецЦикла; 
		
		// заполняем набор записей
		ПропуститьТекущийОбъект = Ложь;
		Для каждого СтрЗаписьНабора Из ТЗПоКлючуОтбора Цикл
			НоваяСтрока = НЗ.Добавить();
			
			Контекст.НомерСтроки = СтрЗаписьНабора.__НомерИсходнойСтроки;
			Контекст.СтрокаДанных = СтрЗаписьНабора;
			
			// заполняем колонки строки
			Для каждого элКолонкаДанных Из ДанныеФайла.КолонкиДанных Цикл
				Контекст.Вставить("ИмяКолонки",элКолонкаДанных.Ключ);
				
				ЗначениеПоля = СтрЗаписьНабора[элКолонкаДанных.Ключ];
				Если ЗначениеПоля <> NULL или УстанавливатьПустоеЗначениеПриЕгоОтсутствии Тогда
					Если элКолонкаДанных.Значение.НестандартноеОбращение Тогда
						УстановитьЗначениеНестандартногоПоля(НоваяСтрока, ДанныеФайла.ТипОбъекта, элКолонкаДанных.Значение, ЗначениеПоля, Контекст, ДанныеОшибки);
					Иначе
						НоваяСтрока[элКолонкаДанных.Ключ] = ЗначениеПоля; 
					КонецЕсли; 
				КонецЕсли; 
				
				Если не ПроверитьЗаполнениеПоля(элКолонкаДанных.Значение, НоваяСтрока[элКолонкаДанных.Ключ]) Тогда
					ДобавитьСобытиеВПротоколСервер(
						"Ошибка",
						"Е91",
						ДанныеФайла.ИмяОбъекта,
						ДанныеФайла.ИмяТЧ,
						Контекст.НомерСтроки,
						СтрШаблон(НСтр("ru='Не заполнено значение колонки ""%1"".'"), элКолонкаДанных.Ключ),
						РезультатПротокол("НЗПропущенИлиОстановка"),
						Контекст.ИмяКолонки
					);
					ПропуститьТекущийОбъект = Истина;
					Если ОстановкаПоОшибке Тогда
						Возврат Ложь;
					Иначе
						Продолжить;
					КонецЕсли; 
				КонецЕсли;
				Если ДанныеОшибки <> Неопределено Тогда
					Пропуск = ПолучитьЗначениеСвойстваСтруктуры(ДанныеОшибки, "Пропуск", "НЗПропущенИлиОстановка");
					Если не СтрНачинаетсяС(ВРег(Пропуск),"КОЛОНКАПРОПУЩЕНА") Тогда
						ДанныеОшибки.Вставить("Пропуск", "НЗПропущенИлиОстановка");
						ПропуститьТекущийОбъект = Истина;
					КонецЕсли; 
					ДобавитьСообщениеВЛогИзСтруктуры(ДанныеОшибки, "Е93", ДанныеФайла, Контекст.НомерСтроки, Контекст.ИмяКолонки);
					Если ОстановкаПоОшибке Тогда
						Возврат Ложь;
					Иначе
						Продолжить;
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла; // по колонкам
			Контекст.Удалить("ИмяКолонки");
			
			// Записываем НЗ
			Если ПропуститьТекущийОбъект = Ложь и Объект.РежимТестированияФайла = Ложь Тогда
				Если не ЗаписатьНаборЗаписей(НЗ, Контекст) и ОстановкаПоОшибке Тогда
					Возврат Ложь; 
				КонецЕсли;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
	
	
	ТЗДанные.Колонки.Удалить("__НомерИсходнойСтроки");
	
	Возврат Истина; 
КонецФункции

&НаСервере
Функция ЗагрузитьТЧИзФайла(ДанныеФайлов, ДанныеФайла)
	
	Перем ИмяКолонкиСсылка, ОбъектСсылка, СсылкаТекущейСтроки, СтрокаДанных, ТекущаяСсылка, ТЗДанные;
	
	ИмяКолонкиСсылка = ИмяСистемнойКолонки("Ссылка", ДанныеФайла);
	ТЗДанные = ДанныеФайла.Данные;
	
	// Проставляем номер исходной строки
	ТЗДанные.Колонки.Добавить("__НомерИсходнойСтроки", Новый ОписаниеТипов("Число"));
	сч = 0;
	Для каждого стр Из ТЗДанные Цикл
		ТЗДанные.__НомерИсходнойСтроки = ДанныеФайла.ДанныеНомерПервойСтроки + сч;
		сч = сч + 1;
	КонецЦикла; 
	
	ТЗДанные.Сортировать(ИмяКолонкиСсылка+", __НомерИсходнойСтроки");
	ТекущаяСсылка = Неопределено;
	ТекущийОбъект = Неопределено;
	ТекущаяТЧ = Неопределено;
	ПропуститьТекущийОбъект = Ложь;
	//ДанныеФайла.Данные.Индексы.Добавить(ИмяКолонкиСсылка);
	//ТабОбъектов = ДанныеФайла.Данные.Скопировать(,ИмяКолонкиСсылка);
	//МассивОбъектов = ТабОбъектов.Свернуть(ИмяКолонкиСсылка).ВыгрузитьКолонку(ИмяКолонкиСсылка);
	//СтруктураОтбора = Новый Структура(ИмяКолонкиСсылка);
	
	Контекст = Новый Структура("ДанныеФайлов, ДанныеФайла, СтрокаДанных, НомерСтроки", ДанныеФайлов, ДанныеФайла);
	Для каждого СтрокаДанных Из ТЗДанные Цикл
		Контекст.Удалить("ИмяКолонки");
		
		Если СтрокаДанных.__Обработано = Истина Тогда
			Продолжить; 
		КонецЕсли;
		
		СтрокаДанных.__Обработано = Истина;
		СсылкаТекущейСтроки = СтрокаДанных[ИмяКолонкиСсылка]; 
		Если НЕ ЗначениеЗаполнено(СсылкаТекущейСтроки) Тогда
			// сообщение об ошибке выдавалось при преобразовании
			Продолжить;
		КонецЕсли;
		
		Если СсылкаТекущейСтроки <> ТекущаяСсылка Тогда
			// объект в текущей строке сменился
			
			// Записываем старый объект
			Если ТекущаяСсылка <> Неопределено и ПропуститьТекущийОбъект=Ложь и не Объект.РежимТестированияФайла Тогда
				Если не ЗаписатьОбъект(ДанныеФайла, СтрокаДанных, ТекущийОбъект, Контекст) и ОстановкаПоОшибке Тогда
					Возврат Ложь;
				КонецЕсли; 
			КонецЕсли;
			
			ТекущаяСсылка = СсылкаТекущейСтроки;			
			ТекущийОбъект = ТекущаяСсылка.ПолучитьОбъект();
			ТекущаяТЧ = ТекущийОбъект[ДанныеФайла.ИмяТЧ];
			ПропуститьТекущийОбъект=Ложь;
			
			Если Объект.НеОчищатьСодержимоеТабличныхЧастей = Ложь Тогда
				ТекущаяТЧ.Очистить();
			КонецЕсли; 
		КонецЕсли;
		
		Контекст.СтрокаДанных = СтрокаДанных;
		Контекст.НомерСтроки = СтрокаДанных.__НомерИсходнойСтроки;
		СсылкаТекущейСтроки = СтрокаДанных[ИмяКолонкиСсылка];
		
		НоваяСтрока = ТекущаяТЧ.Добавить();
		//ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаДанных,, ИмяКолонкиСсылка+", __НомерИсходнойСтроки");
		Для каждого элКолонкаДанных Из ДанныеФайла.КолонкиДанных Цикл
			Контекст.Вставить("ИмяКолонки",элКолонкаДанных.Ключ);
			ЗначениеПоля = СтрокаДанных[элКолонкаДанных.Ключ];
  	        Если ЗначениеПоля <> NULL или УстанавливатьПустоеЗначениеПриЕгоОтсутствии Тогда
				НоваяСтрока[элКолонкаДанных.Ключ] = ЗначениеПоля; 
			КонецЕсли; 
			
			Если не ПроверитьЗаполнениеПоля(элКолонкаДанных.Значение, НоваяСтрока[элКолонкаДанных.Ключ]) Тогда
				ДобавитьСобытиеВПротоколСервер(
					"Ошибка",
					"Е86",
					ДанныеФайла.ИмяОбъекта,
					ДанныеФайла.ИмяТЧ,
					Контекст.НомерСтроки,
					СтрШаблон(НСтр("ru='Не заполнено значение колонки ""%1"".'"), элКолонкаДанных.Ключ),
					РезультатПротокол("ТЧОбъектаПропущенаИлиОстановка"),
					Контекст.ИмяКолонки
				);
				ПропуститьТекущийОбъект = Истина;
				Продолжить;
			КонецЕсли;
		КонецЦикла; // по колонкам
	КонецЦикла;

	// Записываем объект
	Если ТекущаяСсылка <> Неопределено и ПропуститьТекущийОбъект=Ложь и не Объект.РежимТестированияФайла Тогда
		Успех = ЗаписатьОбъект(ДанныеФайла, СтрокаДанных, ТекущийОбъект, Контекст);
		Если не Успех Тогда
			Если ОстановкаПоОшибке Тогда
				Возврат Ложь;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	
	ТЗДанные.Колонки.Удалить("__НомерИсходнойСтроки");
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ИмяСистемнойКолонки(ИмяКолонки, ДанныеФайла)
	Возврат "__"+ИмяКолонки; 
КонецФункции 

&НаСервере
Функция ЗагрузитьОбъект(ДанныеФайлов, ДанныеФайла, СтрокаДанных, знач НомерСтроки)
	
	КолонкаИД = Неопределено;
	Если ДанныеФайла.ДопСвойства.Свойство("КолонкаИД", КолонкаИД) и ЗначениеЗаполнено(СтрокаДанных[КолонкаИД]) Тогда
		ИД = СтрокаДанных[КолонкаИД];
		ДанныеОшибки = Неопределено;
		СсылкаПоИД = ПолучитьСсылкуПоID(Объект.Источник, ДанныеФайла.ИмяОбъекта, ИД, ДанныеОшибки);
		Если ДанныеОшибки <> Неопределено Тогда
			ДобавитьСообщениеВЛогИзСтруктуры(ДанныеОшибки, "Е50", ДанныеФайла, НомерСтроки, "ID");
			Возврат Ложь; 
		КонецЕсли;
	Иначе
		ИД = "";
		СсылкаПоИД = Неопределено;
	КонецЕсли;
	
	КолонкаРеф = Неопределено;
	Если ДанныеФайла.ДопСвойства.Свойство("КолонкаРеф", КолонкаРеф) и ЗначениеЗаполнено(СтрокаДанных[КолонкаРеф]) Тогда
		Реф = СтрокаДанных[КолонкаРеф];
		ДанныеОшибки = Неопределено;
		СсылкаПоРеф = ПолучитьСсылкуПоRef(ДанныеФайла.МенеджерОбъекта, Реф, ДанныеОшибки);
		Если ДанныеОшибки <> Неопределено Тогда
			ДобавитьСообщениеВЛогИзСтруктуры(ДанныеОшибки, "Е51", ДанныеФайла, НомерСтроки, "Ref");
			Возврат Ложь; 
		КонецЕсли;
	Иначе
		Реф = "";
		СсылкаПоРеф = Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СсылкаПоИД) и ЗначениеЗаполнено(СсылкаПоРеф) и СсылкаПоИД <> СсылкаПоРеф Тогда
		ДобавитьСобытиеВПротоколСервер(
			"Ошибка",
			"Е52",
			ДанныеФайла.ИмяОбъекта,
			ДанныеФайла.ИмяТЧ,
			НомерСтроки,
			СтрШаблон(
				НСтр("ru='В файле ""%1"" ссылка, полученная из поля ""ID"" (%2) не соответствует ссылке, полученной из поля ""Ref"" (%3).'"),
				ДанныеФайла.ИмяФайла, 
				ИД,
				Реф),
			РезультатПротокол("СтрокаПропущенаИлиОстановка")
		);
		Возврат Ложь; 
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(СсылкаПоИД) Тогда // ИД тоже заполнено
		СсылкаНайдено = СсылкаПоИД;
		Режим = "*"; // модификация
		ЗаписыватьСоответствие = Ложь;
	ИначеЕсли ЗначениеЗаполнено(СсылкаПоРеф) Тогда // здесь всегда Реф будет тоже заполнено
		ЗаписыватьСоответствие = ЗначениеЗаполнено(ИД);
		Если БитаяСсылка(СсылкаПоРеф) Тогда
			Режим = "+";
		Иначе
			Режим = "*";
			СсылкаНайдено = СсылкаПоРеф;
		КонецЕсли;
	ИначеЕсли ЗначениеЗаполнено(ИД) Тогда // ИД заполнено, но ссылка не найдена 
		Режим = "+";
		ЗаписыватьСоответствие = Истина;
	Иначе // ни Ref, ни ID не заполнены
		ДобавитьСобытиеВПротоколСервер(
			"Ошибка",
			"Е53",
			ДанныеФайла.ИмяОбъекта,
			ДанныеФайла.ИмяТЧ,
			НомерСтроки,
			СтрШаблон(
				НСтр("ru='В файле ""%1"" не заполнены колонки ""ID"" и ""Ref"".'"),
				ДанныеФайла.ИмяФайла), 
			?(не ОстановкаПоОшибке,
				РезультатПротокол().СтрокаПропущена,
				РезультатПротокол().Остановка
			)
		);
		Возврат Ложь; 
		
	КонецЕсли; 
	
	Если Режим = "+" и не Объект.СоздаватьНовыеОбъекты Тогда
		ДобавитьСобытиеВПротоколСервер(
			"Предупреждение",
			"Е54",
			ДанныеФайла.ИмяОбъекта,
			ДанныеФайла.ИмяТЧ,
			НомерСтроки,
			НСтр("ru='Невозможно создать новый объект, поскольку не взведен флаг ""Создавать новые объекты"".'"),
			РезультатПротокол().СтрокаПропущена 
		);
		Возврат Истина; 
	ИначеЕсли Режим = "*" и не Объект.ИзменятьСуществующиеОбъекты Тогда
		ДобавитьСобытиеВПротоколСервер(
			"Предупреждение",
			"Е55",
			ДанныеФайла.ИмяОбъекта,
			ДанныеФайла.ИмяТЧ,
			НомерСтроки,
			НСтр("ru='Невозможно изменить существующий объект, поскольку не взведен флаг ""Изменять существующие объекты"".'"),
			РезультатПротокол().СтрокаПропущена 
		);
		Возврат Истина; 
	КонецЕсли; 
	
	элКолЭтоГруппа = Неопределено;
	ЭтоГруппа = Ложь;
	ИмеетсяПризнакГруппы = Истина;
	Если ДанныеФайла.КолонкиДанных.Свойство("ЭтоГруппа", элКолЭтоГруппа) и 
		(СтрСравнить(ДанныеФайла.ТипОбъекта, "Справочник") = 0 или СтрСравнить(ДанныеФайла.ТипОбъекта, "ПланВидовХарактеристик") = 0)
	Тогда
		ИмеетсяПризнакГруппы = Истина;
		Если не ПреобразоватьВЗначениеБулево(ЭтоГруппа, СтрокаДанных.ЭтоГруппа, Ложь) Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Ошибка",
				"Е120",
				ДанныеФайла.ИмяОбъекта,
				ДанныеФайла.ИмяТЧ,
				НомерСтроки,
				НСтр("ru='Невозможно преобразовать к типу Булево значение поля ""ЭтоГруппа"".'"),
				РезультатПротокол("СтрокаПропущенаИлиОстановка"),
				"ЭтоГруппа"
			);
		    Возврат Ложь; 
		КонецЕсли;  
	КонецЕсли; 
	
	Если Режим = "*" Тогда
		ОбъектДляЗагрузки = СсылкаНайдено.ПолучитьОбъект();
		Если ИмеетсяПризнакГруппы и ЭтоГруппа <> ОбъектДляЗагрузки.ЭтоГруппа и ЗначениеЗаполнено(СтрокаДанных.ЭтоГруппа) Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Ошибка",
				"Е121",
				ДанныеФайла.ИмяОбъекта,
				ДанныеФайла.ИмяТЧ,
				НомерСтроки,
				СтрШаблон(
					НСтр("ru='Невозможно изменить у объекта принадлежность к группе. В базе %1, а загружается %2.'"),
					?(ОбъектДляЗагрузки.ЭтоГруппа, НСтр("ru='записана группа'"), НСтр("ru='записан элемент'")),
					?(ЭтоГруппа, НСтр("ru='группа'"), НСтр("ru='элемент'"))
				),
				РезультатПротокол("СтрокаПропущенаИлиОстановка"),
				"ЭтоГруппа"
			);
		    Возврат Ложь; 
		КонецЕсли; 
	Иначе // создать новый
		Если ЭтоГруппа Тогда
		
			ОбъектДляЗагрузки = СоздатьГруппу(ДанныеФайла);
			
			КодОшибки = "Е56";
			ТекстОшибки = СтрШаблон(НСтр("ru='Тип ""%1"" не может иметь групп.'"), ДанныеФайла.ИмяОбъекта); 
		Иначе
			ОбъектДляЗагрузки = СоздатьЭлемент(ДанныеФайла);
			КодОшибки = "Е57";
			ТекстОшибки = СтрШаблон(НСтр("ru='Невозможно создать новый элемент с типом ""%1"".'"), ДанныеФайла.ИмяОбъекта); 
		КонецЕсли;
		
		Если ОбъектДляЗагрузки = Неопределено Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Ошибка",
				КодОшибки,
				ДанныеФайла.ИмяОбъекта,
				ДанныеФайла.ИмяТЧ,
				НомерСтроки,
				ТекстОшибки,
				РезультатПротокол().ФайлПропущен
			);
			ДанныеФайла.ДопСвойства.Вставить("ПропуститьФайл", Истина);
			Возврат Ложь; 
		ИначеЕсли ЗначениеЗаполнено(СсылкаПоРеф) Тогда
			ОбъектДляЗагрузки.УстановитьСсылкуНового(СсылкаПоРеф);
		КонецЕсли; 
				 
	КонецЕсли; 
	
	Контекст = Новый Структура("ДанныеФайлов, ДанныеФайла, СтрокаДанных, НомерСтроки", ДанныеФайлов, ДанныеФайла, СтрокаДанных, НомерСтроки);
	Успех = ЗаполнитьОбъект(ДанныеФайлов, ДанныеФайла, СтрокаДанных, ОбъектДляЗагрузки, Контекст);
	СтрокаДанных.__Обработано = Истина;
	
	Если не Объект.РежимТестированияФайла Тогда
		Успех = Успех И ЗаписатьОбъект(ДанныеФайла, СтрокаДанных, ОбъектДляЗагрузки, Контекст);
	КонецЕсли;
	
	Если Успех Тогда
		ЗаписатьСоответствиеОбъектаПоID(Объект.Источник, ДанныеФайла.ИмяОбъекта, ИД, ОбъектДляЗагрузки.Ссылка, Объект.РежимТестированияФайла);
	КонецЕсли; 
	
	Возврат Успех; 
КонецФункции

&НаСервере
Функция ЗаполнитьОбъект(ДанныеФайлов, ДанныеФайла, СтрокаДанных, ОбъектДляЗагрузки, Контекст)
	УстанавливатьЗначение = Ложь;
	Отказ = Ложь;
	
	//шапка
	Для каждого элКолонкаДанных Из ДанныеФайла.КолонкиДанных Цикл
		Контекст.Вставить("ИмяКолонки",элКолонкаДанных.Ключ);
		Если РеквизитУстанавливаетсяОсобымОбразом(ДанныеФайла, элКолонкаДанных.Ключ) Тогда
			Продолжить;
		КонецЕсли;
		ДанныеОшибки = Неопределено;
		ЗначениеПоля = ПолучитьЗначениеПоля(ДанныеФайла, СтрокаДанных, элКолонкаДанных.Значение, УстанавливатьПустоеЗначениеПриЕгоОтсутствии, УстанавливатьЗначение, ДанныеОшибки, Контекст);
		Если ДанныеОшибки = Неопределено Тогда
			Если УстанавливатьЗначение Тогда
				// нестандартное обращение сейчас используется только для регистра бухгалтерии.
				//Если элКолонкаДанных.Значение.НестандартноеОбращение Тогда
				//	УстановитьЗначениеНестандартногоПоля(ОбъектДляЗагрузки, ДанныеФайла.ТипОбъекта, элКолонкаДанных.Значение, ЗначениеПоля, Контекст, ДанныеОшибки);
				//Иначе
				ОбъектДляЗагрузки[элКолонкаДанных.Ключ] = ЗначениеПоля; 
				//КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Если ДанныеОшибки = Неопределено Тогда
			Если не ПроверитьЗаполнениеПоля(элКолонкаДанных.Значение, ОбъектДляЗагрузки[элКолонкаДанных.Ключ]) Тогда
				ДобавитьСобытиеВПротоколСервер(
					"Ошибка",
					"Е61",
					ДанныеФайла.ИмяОбъекта,
					ДанныеФайла.ИмяТЧ,
					Контекст.НомерСтроки,
					СтрШаблон(НСтр("ru='Не заполнено значение колонки ""%1"".'"), элКолонкаДанных.Ключ),
					РезультатПротокол("СтрокаПропущенаИлиОстановка"),
					Контекст.ИмяКолонки
				);
  				Отказ = Истина;
				Продолжить;  
			КонецЕсли;
		КонецЕсли; 
		
		Если ДанныеОшибки <> Неопределено Тогда
			ДобавитьСообщениеВЛогИзСтруктурыКонтекст(ДанныеОшибки, "Е62", Контекст);
			Если ОстановкаПоОшибке = Ложь Тогда
				Пропуск = ПолучитьЗначениеСвойстваСтруктуры(ДанныеОшибки, "Пропуск", "");
				Если СтрНачинаетсяС(Врег(Пропуск), "КОЛОНКАПРОПУЩЕНА") Тогда
					Продолжить;
				Иначе
					Отказ = Истина;
				КонецЕсли;
			Иначе
				Отказ = Истина;
			КонецЕсли; 
		КонецЕсли; 		
	КонецЦикла; 
	Контекст.Удалить("ИмяКолонки");
	
	Если Отказ Тогда
		Возврат Ложь; 
	КонецЕсли; 
	
	
	// ТЧ
	Если НЕ Объект.НеОчищатьТЧПриЗагрузкеОбъекта Тогда
		// очищаем содержимое ТЧ, на которые есть файлы ТЧ к загрузке
		ФайлыОбъекта = ДанныеФайлов.НайтиСтроки(Новый Структура("ИмяОбъекта", ДанныеФайла.ИмяОбъекта));
		Для каждого ФайлТЧ Из ФайлыОбъекта Цикл
			Если ФайлТЧ = ДанныеФайла или ПустаяСтрока(ФайлТЧ.ИмяТЧ) Тогда
				Продолжить;
			КонецЕсли; 
			
			Если ДанныеФайлов.Индекс(ФайлТЧ) < ДанныеФайлов.Индекс(ДанныеФайла) Тогда
				// уже загружали данную ТЧ
				ДобавитьСобытиеВПротоколСервер(
					"Предупреждение",
					"Е60",
					ДанныеФайла.ИмяОбъекта,
					ДанныеФайла.ИмяТЧ,
					Контекст.НомерСтроки,
					СтрШаблон(НСтр("ru='Табличная часть ""%1"" уже загружалась для объекта ""%2"", поэтому очищаться не будет.'"), ФайлТЧ.ИмяТЧ, ДанныеФайла.ИмяОбъекта), 
					СтрШаблон(НСтр("ru='Табличная часть ""%1"" не очищена'"), ФайлТЧ.ИмяТЧ) 
				);
			Иначе
				ОбъектДляЗагрузки[ФайлТЧ.ИмяТЧ].Очистить(); 
				
				//TODO: вставить сюда рекурсивное заполнение табличных частей
			КонецЕсли; 
			Прервать; 
		КонецЦикла; 
	КонецЕсли;
	
	Возврат Истина; 
КонецФункции

&НаСервере
Процедура УстановитьЗначениеНестандартногоПоля(ОбъектДляЗагрузки, знач ТипОбъекта, ОписаниеКолонки, ЗначениеПоля, Контекст, ДанныеОшибки)
	ТипОбъекта = ВРег(ТипОбъекта);
	ИмяРеквизита = ОписаниеКолонки.Имя1С;
	ИмяРеквизитаВрег = ОписаниеКолонки.Имя1С_ВРег;
	
	// проверка того, что для регистра бухгалтерии в случае наличия колонки СубконтоХДК есть колонка СчетДК, производится на этапе формирования таблицы Описание для данного файла.
	Если ТипОбъекта = "РЕГИСТРБУХГАЛТЕРИИ" и СтрНачинаетсяС(ИмяРеквизитаВрег,"СУБКОНТО") Тогда
		Если СтрЗаканчиваетсяНа(ИмяРеквизитаВрег, "ДТ") Тогда
			Субконто = ОбъектДляЗагрузки.СубконтоДт;
			Счет = Контекст.СтрокаДанных.СчетДт;
			СчетОб = ОбъектДляЗагрузки.СчетДт;
			Направление = "Дт";
		ИначеЕсли СтрЗаканчиваетсяНа(ИмяРеквизитаВрег, "КТ") Тогда 
			Субконто = ОбъектДляЗагрузки.СубконтоКт; 
			Счет = Контекст.СтрокаДанных.СчетКт;
			СчетОб = ОбъектДляЗагрузки.СчетКт;
			Направление = "Кт";
		Иначе
			ДанныеОшибки = Новый Структура("Текст, Код, Пропуск",
				СтрШаблон(
					НСтр("ru='Внутренняя ошибка при установке значения субконто: некорректное имя поля ""%1"".'"),
					ИмяРеквизита
				),
				"Е79",
				"КолонкаПропущенаИлиОстановка"
			);
			Возврат; 			
		КонецЕсли;
		
		Если Счет = NULL Тогда
			Счет = СчетОб;
		КонецЕсли; 
		
		Если не ЗначениеЗаполнено(Счет) Тогда
			ДанныеОшибки = Новый Структура("Текст, Код, Пропуск",
				СтрШаблон(
					НСтр("ru='Невозможно установить ""%1"", поскольку ""Счет%2"" не заполнен.'"),
					ИмяРеквизита, Направление 
				),
				"Е80",
				"СтрокаПропущенаИлиОстановка"
			);
			Возврат; 			
		КонецЕсли;
		
		КэшДанныхСчета = сКэшДанныхСчета[Счет];
		Если КэшДанныхСчета = Неопределено Тогда
			КэшДанныхСчета = Счет.ВидыСубконто.ВыгрузитьКолонку("ВидСубконто");
			сКэшДанныхСчета.Вставить(Счет, КэшДанныхСчета);
		КонецЕсли; 
		
		Если КэшДанныхСчета.Количество() < ОписаниеКолонки.НомерСубконто  Тогда
			ДанныеОшибки = Новый Структура("Текст, Код, Пропуск",
				СтрШаблон(
					НСтр("ru='Невозможно установить Субконто %1 (%2), поскольку у Cчета (%2) ""%3"" количество субконто - %4.'"),
					ОписаниеКолонки.НомерСубконто, Направление, Счет, КэшДанныхСчета.Количество()
				),
				"Е81",
				"КолонкаПропущенаИлиОстановка"
			);
			Возврат; 			
		КонецЕсли;
		
		Субконто[КэшДанныхСчета[ОписаниеКолонки.НомерСубконто-1]] = ЗначениеПоля; 
	КонецЕсли; 
КонецПроцедуры
 
&НаСервере
Функция ПроверитьЗаполнениеПоля(СтрокаОписания, ПроверяемоеЗначение)
	Если СтрокаОписания.ПроверятьЗаполнение <> Истина Тогда
		Возврат Истина; 
	КонецЕсли; 
	Если ЗначениеЗаполнено(ПроверяемоеЗначение) Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь; 
	КонецЕсли; 
КонецФункции 

&НаСервереБезКонтекста
Функция СуществуетРеквизитОбъекта(знач мдОбъекта, знач ИмяТипа, знач ИмяТЧ, знач ИмяРеквизита, ТолькоЧтение = Ложь, мдРеквизит = NULL, стрОписание = NULL)
	ИмяРеквизита = ВРег(ИмяРеквизита);
	ИмяТипа = ВРег(ИмяТипа);
	
	// у перечислений нет реквизитов
	Если СтрСравнить(ИмяТипа, "Перечисление") = 0 Тогда
		Возврат Ложь; 
	КонецЕсли;
		
	Если ПустаяСтрока(ИмяТЧ) Тогда
		// реквизиты есть у любого типа. И они не могут быть балансовыми
		мдРеквизит = мдОбъекта.Реквизиты.Найти(ИмяРеквизита);
		Если мдРеквизит <> Неопределено Тогда
			Возврат Истина; 
		КонецЕсли;
	КонецЕсли; 
	
	ЭтоСтандартныйРеквизит = Ложь;
	
	// сюда попадаем, если это не ТЧ
	РегистрИмеетПериод = Неопределено;
    РегистрПодчиненРегистратору = Неопределено;
    ЭтоРегистрБухгалтерии = Неопределено;
	ЭтоРегистрНакопления = Неопределено;
	Если ПолучитьАтрибутыРегистра(ИмяТипа, мдОбъекта, РегистрИмеетПериод, РегистрПодчиненРегистратору, ЭтоРегистрБухгалтерии, ЭтоРегистрНакопления,) Тогда
		// все регистры (РЕГИСТРСВЕДЕНИЙ, РЕГИСТРНАКОПЛЕНИЯ, РЕГИСТРБУХГАЛТЕРИИ, РЕГИСТРРАСЧЕТА)
		
		Если РегистрИмеетПериод и ИмяРеквизита = "ПЕРИОД" Тогда
			ЭтоСтандартныйРеквизит = Истина;	
		
		ИначеЕсли РегистрПодчиненРегистратору и (ИмяРеквизита = "РЕГИСТРАТОР" или ИмяРеквизита = "АКТИВНОСТЬ") Тогда
			ЭтоСтандартныйРеквизит = Истина;
		ИначеЕсли ЭтоРегистрНакопления и ИмяРеквизита = "ВИДДВИЖЕНИЯ" Тогда
			ЭтоСтандартныйРеквизит = мдОбъекта.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки;
		КонецЕсли; 
		
		Если не ЭтоСтандартныйРеквизит Тогда
			// измерения. Для регистра бухгалтерии берем только балансовые измерения
			мдРеквизит = мдОбъекта.Измерения.Найти(ИмяРеквизита);
			Если мдРеквизит <> Неопределено и (ЭтоРегистрБухгалтерии = Ложь или мдРеквизит.Балансовый = Истина) Тогда
				Возврат Истина; 
			КонецЕсли; 
			// ресурсы. Для регистра бухгалтерии берем только балансовые ресурсы
			мдРеквизит = мдОбъекта.Ресурсы.Найти(ИмяРеквизита);
			Если мдРеквизит <> Неопределено и (ЭтоРегистрБухгалтерии = Ложь или мдРеквизит.Балансовый = Истина) Тогда
				Возврат Истина; 
			КонецЕсли; 

			Если ЭтоРегистрБухгалтерии Тогда
				// измерения. Для регистра бухгалтерии берем только балансовые измерения
				// балансовые измерения 
				Если СтрНайти("|ДТ|КТ|","|"+Прав(ИмяРеквизита, 2)+"|") > 0 Тогда
					ИмяРеквизитаБезПостфикса = Лев(ИмяРеквизита, СтрДлина(ИмяРеквизита)-2);
					Если СтрСравнить(ИмяРеквизитаБезПостфикса, "Счет") = 0 Тогда
						ЭтоСтандартныйРеквизит = Истина; 
					ИначеЕсли СтрНачинаетсяС(ИмяРеквизитаБезПостфикса, "СУБКОНТО") Тогда
						СтрНомерСубконто = Сред(ИмяРеквизитаБезПостфикса, 9);
						НомерСубконто = 0;
						Если ПолучитьЧислоИзСтроки(НомерСубконто, СтрНомерСубконто) и НомерСубконто > 0 и НомерСубконто <= мдОбъекта.ПланСчетов.МаксКоличествоСубконто Тогда
							ЭтоСтандартныйРеквизит = Истина;
							Если стрОписание <> NULL Тогда
								стрОписание.НестандартноеОбращение = Истина;
								стрОписание.НомерСубконто = НомерСубконто;
							КонецЕсли; 
							НестандартноеОбращение = Истина;
						КонецЕсли;
					КонецЕсли; 
					
					Если не ЭтоСтандартныйРеквизит Тогда
						мдРеквизит = мдОбъекта.Ресурсы.Найти(ИмяРеквизитаБезПостфикса);
						Если мдРеквизит <> Неопределено и мдРеквизит.Балансовый = Ложь Тогда
							Возврат Истина; 
						КонецЕсли;
						мдРеквизит = мдОбъекта.Ресурсы.Найти(ИмяРеквизитаБезПостфикса);
						Если мдРеквизит <> Неопределено и мдРеквизит.Балансовый = Ложь Тогда
							Возврат Истина; 
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли;
			
			// регистр расчета не обрабатываем на данный момент
		КонецЕсли;
		
		Если ЭтоСтандартныйРеквизит Тогда
			Если мдРеквизит <> NULL Тогда
				мдРеквизит = ПолучитьСтандартныйРеквизит(мдОбъекта, ИмяРеквизита);
			КонецЕсли; 
			Возврат Истина; 
		КонецЕсли;
		
	КонецЕсли;
	
	// объектный тип
	
	// у объектного типа всегда могут быть ТЧ
	Если ЗначениеЗаполнено(ИмяТЧ) Тогда
		// проверяем, что данная ТЧ есть у объекта
		мдТЧ = мдОбъекта.ТабличныеЧасти.Найти(ИмяТЧ);
		Если мдТЧ = Неопределено Тогда
			Возврат Ложь; 
		КонецЕсли; 
		
		Возврат мдТЧ.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	КонецЕсли; 
	
	
	// объектный тип, не ТЧ
	Если ИмяРеквизита = "ССЫЛКА" ИЛИ ИмяРеквизита = "ПОМЕТКАУДАЛЕНИЯ" Тогда
		ЭтоСтандартныйРеквизит = Истина;
		
	// у проверяем, если есть предопределенные
	ИначеЕсли (ИмяРеквизита = "ИМЯПРЕДОПРЕДЕЛЕННЫХДАННЫХ" или ТолькоЧтение и ИмяРеквизита = "ПРЕДОПРЕДЕЛЕННЫЙ") 
		И СтрНайти("|СПРАВОЧНИК|ПЛАНВИДОВХАРАКТЕРИСТИК|ПЛАНСЧЕТОВ|ПЛАНВИДОВРАСЧЕТА|","|"+ИмяТипа+"|") > 0 
	Тогда
		ЭтоСтандартныйРеквизит = Истина;
	ИначеЕсли СтрНайти("|СПРАВОЧНИК|ПЛАНВИДОВХАРАКТЕРИСТИК|ПЛАНСЧЕТОВ|ПЛАНВИДОВРАСЧЕТА|ПЛАНОБМЕНА|","|"+ИмяТипа+"|") > 0 Тогда
		// объекты, у которых есть код и наименование
		Если ИмяРеквизита = "КОД" Тогда
			ЭтоСтандартныйРеквизит = мдОбъекта.ДлинаКода  > 0; 
		ИначеЕсли ИмяРеквизита = "НАИМЕНОВАНИЕ" Тогда 
			ЭтоСтандартныйРеквизит = мдОбъекта.ДлинаНаименования  > 0; 
		КонецЕсли;
	ИначеЕсли СтрНайти("|ДОКУМЕНТ|ЗАДАЧА|БИЗНЕСПРОЦЕСС|","|"+ИмяТипа+"|") > 0 Тогда 	
		Если ИмяРеквизита = "НОМЕР" Тогда
			ЭтоСтандартныйРеквизит = мдОбъекта.ДлинаНомера > 0; 
		ИначеЕсли ИмяРеквизита = "ДАТА" Тогда 
			ЭтоСтандартныйРеквизит = Истина; 
		КонецЕсли;
	КонецЕсли;
	
	
	Если ЭтоСтандартныйРеквизит Тогда
		Если мдРеквизит <> NULL Тогда
			мдРеквизит = ПолучитьСтандартныйРеквизит(мдОбъекта, ИмяРеквизита);
		КонецЕсли; 
		Возврат Истина; 
	КонецЕсли; 
	
	// Индивидуальные особенности разных типов
	Если ИмяТипа = "СПРАВОЧНИК" или ИмяТипа = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда 	
		ЭтоСправочник = (ИмяТипа = "СПРАВОЧНИК");
		
		// стандартные реквизиты
		Если ИмяРеквизита = "РОДИТЕЛЬ" Тогда 
			ЭтоСтандартныйРеквизит = мдОбъекта.Иерархический;
		ИначеЕсли ИмяРеквизита = "ЭТОГРУППА" Тогда
			Если ЭтоСправочник Тогда
				ЭтоСтандартныйРеквизит = мдОбъекта.Иерархический и мдОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов;
			Иначе
				ЭтоСтандартныйРеквизит = мдОбъекта.Иерархический;
			КонецЕсли;
		ИначеЕсли ИмяРеквизита = "ВЛАДЕЛЕЦ" Тогда
			ЭтоСтандартныйРеквизит = ЭтоСправочник и мдОбъекта.Владельцы.Количество() > 0;
		КонецЕсли; 
		
	ИначеЕсли ИмяТипа = "ДОКУМЕНТ" Тогда
		// стандартные реквизиты
		Если ИмяРеквизита = "ПРОВЕДЕН" Тогда 
			ЭтоСтандартныйРеквизит = мдОбъекта.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить; 
		КонецЕсли; 
	ИначеЕсли ИмяТипа = "ПЛАНСЧЕТОВ" Тогда 	
		Если ИмяРеквизита = "КОД" Тогда
			ЭтоСтандартныйРеквизит = мдОбъекта.ДлинаКода  > 0; 
		ИначеЕсли ИмяРеквизита = "НАИМЕНОВАНИЕ" Тогда 
			ЭтоСтандартныйРеквизит = мдОбъекта.ДлинаНаименования  > 0; 
		ИначеЕсли СтрНайти("|ПОРЯДОК|РОДИТЕЛЬ|ВИД|ЗАБАЛАНСОВЫЙ|", "|"+ИмяРеквизита+"|") Тогда 
			ЭтоСтандартныйРеквизит = Истина;
		КонецЕсли;	
			
		Если не ЭтоСтандартныйРеквизит Тогда
			мдРеквизит = мдОбъекта.ПризнакиУчета.Найти(ИмяРеквизита);
			Если мдРеквизит <> Неопределено Тогда
				Возврат Истина; 
			КонецЕсли; 
			мдРеквизит = мдОбъекта.ПризнакиУчетаСубконто.Найти(ИмяРеквизита);
			Если мдРеквизит <> Неопределено Тогда
				Возврат Истина; 
			КонецЕсли; 
		КонецЕсли; 
		
	ИначеЕсли ИмяТипа = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Если ИмяРеквизита = "ПЕРИОДДЕЙСТВИЯБАЗОВЫЙ" Тогда 
			ЭтоСтандартныйРеквизит = мдОбъекта.ИспользованиеПериодаДействия; 
		КонецЕсли; 
	ИначеЕсли ИмяТипа = "БИЗНЕСПРОЦЕСС" Тогда
		Если СтрНайти("|ВЕДУЩАЯЗАДАЧА|СТАРТОВАН|ЗАВЕРШЕН|", "|"+ИмяРеквизита+"|") Тогда 
			ЭтоСтандартныйРеквизит = Истина;
		КонецЕсли;
	ИначеЕсли ИмяТипа = "ЗАДАЧА" Тогда
		Если ИмяРеквизита = "НАИМЕНОВАНИЕ" Тогда 
			ЭтоСтандартныйРеквизит = мдОбъекта.ДлинаНаименования  > 0;
		ИначеЕсли ИмяРеквизита = "ВЫПОЛНЕНА" Тогда 
			ЭтоСтандартныйРеквизит = Истина;
		ИначеЕсли ИмяРеквизита = "БИЗНЕСПРОЦЕСС" или ИмяРеквизита = "ТОЧКАМАРШРУТА" Тогда
			Для каждого мдБП Из Метаданные.БизнесПроцессы Цикл
				Если мдБП.Задача = мдОбъекта Тогда
					ЭтоСтандартныйРеквизит = Истина;
					Прервать;
				КонецЕсли; 
			КонецЦикла; 
		КонецЕсли;
		
		Если не ЭтоСтандартныйРеквизит Тогда
			мдРеквизит = мдОбъекта.РеквизитыАдресации.Найти(ИмяРеквизита);
			Если мдРеквизит <> Неопределено Тогда
				Возврат Истина; 
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ИмяТипа = "ПЛАНОБМЕНА" Тогда
		Если ТолькоЧтение и ИмяРеквизита = "ЭТОТУЗЕЛ" Тогда
			ЭтоСтандартныйРеквизит = Истина;
		ИначеЕсли СтрНайти("|НОМЕРОТПРАВЛЕННОГО|НОМЕРПРИНЯТОГО|", "|"+ИмяРеквизита+"|") Тогда 
			ЭтоСтандартныйРеквизит = Истина;
		КонецЕсли;
	Иначе
		// данный тип не поддерживается
		Возврат Ложь; 
	КонецЕсли; 
	
	Если ЭтоСтандартныйРеквизит Тогда
		Если мдРеквизит <> NULL Тогда
			мдРеквизит = ПолучитьСтандартныйРеквизит(мдОбъекта, ИмяРеквизита);
		КонецЕсли; 
		Возврат Истина; 
	КонецЕсли; 
	
	// еще может быть общий реквизит
	Если Метаданные.ОбщиеРеквизиты.Найти(ИмяРеквизита) <> Неопределено Тогда
		мдРеквизит = Метаданные.ОбщиеРеквизиты[ИмяРеквизита];
		ЭлементСостава = мдРеквизит.Состав.Найти(мдОбъекта);
		Если ЭлементСостава = Неопределено Тогда
			Возврат Ложь; 
		КонецЕсли;
		Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать 
			или ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Авто 
				и мдРеквизит.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать 
		Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;  
		КонецЕсли; 
	КонецЕсли; 
КонецФункции 

&НаСервереБезКонтекста
Функция ПолучитьАтрибутыРегистра(Знач ИмяТипа, Знач мдОбъекта, РегистрИмеетПериод, РегистрПодчиненРегистратору, ЭтоРегистрБухгалтерии, ЭтоРегистрНакопления, ЭтоРегистрСведений)
	ИмяТипа = ВРег(ИмяТипа);
	РегистрИмеетПериод = Ложь;
	РегистрПодчиненРегистратору = Ложь;
	ЭтоРегистрБухгалтерии = Ложь;
	ЭтоРегистрНакопления = Ложь;
	ЭтоРегистрСведений = Ложь;

	Если не СтрНачинаетсяС(ВРег(ИмяТипа), "РЕГИСТР") Тогда
		Возврат Ложь; 
	КонецЕсли; 
	
	ЭтоРегистрНакопления = (ИмяТипа="РЕГИСТРНАКОПЛЕНИЯ");
	ЭтоРегистрБухгалтерии = (ИмяТипа="РЕГИСТРБУХГАЛТЕРИИ");
	ЭтоРегистрСведений = (ИмяТипа="РЕГИСТРСВЕДЕНИЙ");
	
	Если мдОбъекта <> Неопределено Тогда
		РегистрПодчиненРегистратору = (ЭтоРегистрСведений = Ложь) или (мдОбъекта.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору);
		РегистрИмеетПериод = ЭтоРегистрНакопления 
			или ЭтоРегистрБухгалтерии 
			или ЭтоРегистрСведений и (мдОбъекта.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический);
	КонецЕсли; 
		
	Возврат Истина; 
КонецФункции 

&НаСервереБезКонтекста
Функция ПолучитьСтандартныйРеквизит(мдОбъекта, ИмяРеквизита)
	стдРекв = Неопределено;
	Попытка
		стдРекв = мдОбъекта.СтандартныеРеквизиты[ИмяРеквизита]; 
	Исключение
	КонецПопытки; 
	Возврат стдРекв;
	
	//Для каждого стдРекв Из мдОбъекта.СтандартныеРеквизиты Цикл
	//	Если СтрСравнить(стдРекв.Имя, ИмяРеквизита) = 0 Тогда
	//		Возврат стдРекв; 
	//	КонецЕсли;  
	//КонецЦикла; 
	//Возврат Неопределено; 
КонецФункции 
  
&НаСервере
Функция ПолучитьРеквизитПоискаПоУмолчанию(знач ИмяТипа)
	ИмяТипа = СокрЛП(ИмяТипа);
	Если СтрСравнить(ИмяТипа, "Справочник") = 0 Тогда
		Возврат ПоискПоСправочникамПоУмолчанию;
	ИначеЕсли СтрСравнить(ИмяТипа, "Документ") = 0 Тогда 
		Возврат ПоискПоДокументамПоУмолчанию;
	ИначеЕсли СтрСравнить(ИмяТипа, "ПланВидовХарактеристик") = 0 Тогда 
		Возврат ПоискПоПВХПоУмолчанию;
	ИначеЕсли СтрСравнить(ИмяТипа, "ПланСчетов") = 0 Тогда 
		Возврат ПоискПоПланамСчетовПоУмолчанию;
	ИначеЕсли СтрСравнить(ИмяТипа, "Перечисление") = 0 Тогда 
		Возврат "$v"; 
	КонецЕсли;                            
КонецФункции
 
&НаКлиентеНаСервереБезКонтекста
Функция РеквизитУстанавливаетсяОсобымОбразом(ДанныеФайла, знач ИмяРеквизита)
	Если ЗначениеЗаполнено(ДанныеФайла.ИмяТЧ) или ДанныеФайла.ОбъектныйТип = Ложь Тогда
		Возврат Ложь; 
	КонецЕсли;
	
	ТипОбъекта = ДанныеФайла.ТипОбъекта;
	
	Если СтрСравнить(ИмяРеквизита, "ПОМЕТКАУДАЛЕНИЯ") = 0 Тогда
		 Возврат Истина; 
	ИначеЕсли СтрСравнить(ТипОбъекта, "Справочник") = 0 или СтрСравнить(ТипОбъекта, "ПланВидовХарактеристик") = 0 Тогда
		Возврат СтрНайти("|ЭТОГРУППА|","|"+ВРег(ИмяРеквизита)+"|") <> 0; 
	ИначеЕсли СтрСравнить(ТипОбъекта, "Документ") = 0 Тогда 
		Если СтрНайти("|ПРОВЕДЕН|","|"+ВРег(ИмяРеквизита)+"|") <> 0 Тогда
			Возврат Истина; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Ложь;
КонецФункции
 
&НаСервере
Функция ЗаписатьНаборЗаписей(НЗ, Контекст)
	
	НЗ.ОбменДанными.Загрузка = Объект.ЗаписыватьДанныеВРежимеЗагрузки;
	
	Попытка
		НЗ.Записать(Объект.ЗаписыватьНаборыЗаписейСЗамещением);
	Исключение
		Инфо = ИнформацияОбОшибке();
	КонецПопытки; 
	
	Если Инфо <> Неопределено Тогда
		
		ТекстОшибки = СформироватьСообщениеОбОшибкеРекурсивно(
			Инфо,
			СтрШаблон(
				НСтр("ru='Ошибка записи %1 набора записей ($Описание). Имя модуля: $ИмяМодуля, строка:  ""$ТекстСтроки"", номер строки: $НомерСтроки'"),
				?(Объект.ЗаписыватьНаборыЗаписейСЗамещением, НСтр("ru='с замещением'"), НСтр("ru='без замещения'"))),
			Символы.ПС+НСтр("ru='по причине'")+Символы.ПС,
			НСтр("ru='$Описание. Имя модуля: $ИмяМодуля, строка:  ""$ИсходнаяСтрока"", номер строки: $НомерСтроки'"),
			".");
			
		Если Объект.ИспользоватьТранзакцию и ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
			ОстановкаПоОшибке = Истина;
		КонецЕсли;
		
		ДобавитьСобытиеВПротоколСервер(
			"Ошибка",
			"Е92",
			Контекст.ДанныеФайла.ИмяОбъекта,
			Контекст.ДанныеФайла.ИмяТЧ,
			Контекст.НомерСтроки,
			ТекстОшибки,
			РезультатПротокол("НЗПропущенИлиОстановка")
		);
		
		Возврат Ложь; 
	КонецЕсли;
	
	Возврат Истина; 
КонецФункции 

&НаСервере
Функция ЗаписатьОбъект(ДанныеФайла, СтрокаДанных, ОбъектДляЗагрузки, Контекст)
	УстанавливатьЗначение = Ложь;
	ДанныеОшибки = Неопределено;
	Если ПустаяСтрока(ДанныеФайла.ИмяТЧ) и ДанныеФайла.КолонкиДанных.Свойство("ПометкаУдаления") Тогда
		НовыйПометкаУдаления = ПолучитьЗначениеПоля(ДанныеФайла, СтрокаДанных, "ПометкаУдаления", Ложь, УстанавливатьЗначение, ДанныеОшибки, Контекст);
		Если ДанныеОшибки <> Неопределено Тогда
			ДанныеОшибки.Вставить("Пропуск", "СтрокаПропущенаИлиОстановка");
			ДобавитьСообщениеВЛогИзСтруктурыКонтекст(ДанныеОшибки, "Е94", Контекст);
			Возврат Ложь; 
		КонецЕсли; 
		Если УстанавливатьЗначение = Ложь Тогда
			НовыйПометкаУдаления = Неопределено;
		КонецЕсли; 
	Иначе
		НовыйПометкаУдаления = Неопределено;
	КонецЕсли;
	
	Инфо = Неопределено;
	ОбъектДляЗагрузки.ОбменДанными.Загрузка = Объект.ЗаписыватьДанныеВРежимеЗагрузки;
	
	Если СтрСравнить(ДанныеФайла.ТипОбъекта,"Документ")=0 Тогда
		Если ПустаяСтрока(ДанныеФайла.ИмяТЧ) и ДанныеФайла.КолонкиДанных.Свойство("Проведен") Тогда
			НовыйПроведен = ПолучитьЗначениеПоля(ДанныеФайла, СтрокаДанных, "Проведен", Ложь, УстанавливатьЗначение, ДанныеОшибки, Контекст);
			Если ДанныеОшибки <> Неопределено Тогда
				ДанныеОшибки.Вставить("Пропуск", "СтрокаПропущенаИлиОстановка");
				ДобавитьСообщениеВЛогИзСтруктурыКонтекст(ДанныеОшибки, "Е95", Контекст);
				Возврат Ложь; 
			КонецЕсли; 
			Если УстанавливатьЗначение = Ложь Тогда
				НовыйПроведен = Неопределено;
			КонецЕсли; 
		Иначе
			НовыйПроведен = Неопределено;
		КонецЕсли;
		
		// обработка ситуаций, когда пометка удаления и проведение влияют друг на друга
		Если НовыйПроведен = Истина и НовыйПометкаУдаления = Неопределено и ОбъектДляЗагрузки.ПометкаУдаления = Истина Тогда
			НовыйПометкаУдаления = Ложь;
		ИначеЕсли НовыйПометкаУдаления = Истина и НовыйПроведен = Неопределено и ОбъектДляЗагрузки.Проведен = Истина Тогда
			НовыйПроведен = Ложь;
		КонецЕсли; 
		
		Если НовыйПроведен = Неопределено Тогда
			НовыйПроведен = ОбъектДляЗагрузки.Проведен;
		КонецЕсли; 
		Если НовыйПометкаУдаления = Неопределено Тогда
			НовыйПометкаУдаления = ОбъектДляЗагрузки.ПометкаУдаления;
		КонецЕсли; 
		
		Если НовыйПроведен = Истина и НовыйПометкаУдаления = Истина Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Ошибка",
				"Е59",
				ДанныеФайла.ИмяОбъекта,
				ДанныеФайла.ИмяТЧ,
				Контекст.НомерСтроки,
				НСтр("ru='Невозможно провести и одновременно пометить на удаление документ.'"),
				РезультатПротокол("СтрокаПропущенаИлиОстановка")
			);
			Возврат Ложь; 
		КонецЕсли;
		
		ОбъектДляЗагрузки.ПометкаУдаления = НовыйПометкаУдаления;
		Если НовыйПроведен = Истина Тогда
			РежимЗаписи = РежимЗаписиДокумента.Проведение;
			ТекстОшибки = НСтр("ru='Ошибка проведения объекта'");
			// при проведении нельзя записывать объект в режиме загрузки - это вызовет ошибку.
			ОбъектДляЗагрузки.ОбменДанными.Загрузка = Ложь;
		ИначеЕсли ОбъектДляЗагрузки.Проведен и НовыйПроведен <> Истина Тогда
			РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения;
			ТекстОшибки = НСтр("ru='Ошибка отмены проведения объекта'");
		Иначе
			РежимЗаписи = РежимЗаписиДокумента.Запись;
			ТекстОшибки = НСтр("ru='Ошибка записи объекта'");
		КонецЕсли; 
		
		Попытка
			ОбъектДляЗагрузки.Записать(РежимЗаписи);
		Исключение
			Инфо = ИнформацияОбОшибке();
		КонецПопытки; 
	Иначе // не документ
		Если НовыйПометкаУдаления <> Неопределено Тогда
			ОбъектДляЗагрузки.ПометкаУдаления = НовыйПометкаУдаления;
		КонецЕсли; 
		
		Попытка
			ОбъектДляЗагрузки.Записать();
		Исключение
			Инфо = ИнформацияОбОшибке();
		КонецПопытки; 
		ТекстОшибки = НСтр("ru='Ошибка записи объекта'");	
	КонецЕсли;
	
	Если Инфо <> Неопределено Тогда
		ТекстОшибки = СформироватьСообщениеОбОшибкеРекурсивно(
			Инфо,
			СтрШаблон(
				НСтр("ru='%1 ($Описание). Имя модуля: $ИмяМодуля, строка:  ""$ИсходнаяСтрока"", номер строки: $НомерСтроки'"),
				ТекстОшибки),
			Символы.ПС+НСтр("ru='по причине'")+Символы.ПС,
			НСтр("ru='$Описание. Имя модуля: $ИмяМодуля, строка:  ""$ИсходнаяСтрока"", номер строки: $НомерСтроки'"),
			".");
		
		Если Объект.ИспользоватьТранзакцию и ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
			ОстановкаПоОшибке = Истина;
		КонецЕсли;
		
		ДобавитьСобытиеВПротоколСервер(
			"Ошибка",
			"Е58",
			ДанныеФайла.ИмяОбъекта,
			ДанныеФайла.ИмяТЧ,
			Контекст.НомерСтроки,
			ТекстОшибки,
			РезультатПротокол(
				?(ЗначениеЗаполнено(ДанныеФайла.ИмяТЧ),
					"ТЧОбъектаПропущенаИлиОстановка",
					"СтрокаПропущенаИлиОстановка"
				)
			)
		);
		
		Возврат Ложь; 
	КонецЕсли;
	
	Возврат Истина; 
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СформироватьСообщениеОбОшибкеРекурсивно(ИнфоОбОшибке, знач ШаблонНачало, знач СтрРазделитель, знач ШаблонПричинаРекурсивно, знач СтрОкончание)
	Перем СтрРезультат;
	ШаблонНачало = СтрЗаменить(ШаблонНачало, "$Описание", ИнфоОбОшибке.Описание); 
	ШаблонНачало = СтрЗаменить(ШаблонНачало, "$ИмяМодуля", ИнфоОбОшибке.ИмяМодуля); 
	ШаблонНачало = СтрЗаменить(ШаблонНачало, "$ИсходнаяСтрока", ИнфоОбОшибке.ИсходнаяСтрока); 
	ШаблонНачало = СтрЗаменить(ШаблонНачало, "$НомерСтроки", ИнфоОбОшибке.НомерСтроки); 
	
	СтрРезультат = ШаблонНачало;
	Если ИнфоОбОшибке.Причина <> Неопределено Тогда
		СтрРезультат = СтрРезультат + СтрРазделитель + 
			СформироватьСообщениеОбОшибкеРекурсивно(ИнфоОбОшибке.Причина, ШаблонПричинаРекурсивно, СтрРазделитель, ШаблонПричинаРекурсивно, "");
	КонецЕсли; 
	
	СтрРезультат = СтрРезультат + СтрОкончание;
	Возврат СтрРезультат; 
КонецФункции
 

&НаСервере
Функция СоздатьЭлемент(ДанныеФайла)
	Если СтрСравнить(ДанныеФайла.ТипОбъекта, "Справочник") = 0 или СтрСравнить(ДанныеФайла.ТипОбъекта, "ПланВидовХарактеристик") = 0 Тогда
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьЭлемент();
	ИначеЕсли СтрСравнить(ДанныеФайла.ТипОбъекта, "Документ") = 0 Тогда 
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьДокумент();
	ИначеЕсли СтрСравнить(ДанныеФайла.ТипОбъекта, "ПланСчетов") = 0 Тогда 
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьСчет();
	ИначеЕсли СтрСравнить(ДанныеФайла.ТипОбъекта, "ПланВидовРасчета") = 0 Тогда 
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьВидРасчета();
	ИначеЕсли СтрСравнить(ДанныеФайла.ТипОбъекта, "БизнесПроцесс") = 0 Тогда 
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьБизнесПроцесс();
	ИначеЕсли СтрСравнить(ДанныеФайла.ТипОбъекта, "Задача") = 0 Тогда 
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьЗадачу();
	ИначеЕсли СтрСравнить(ДанныеФайла.ТипОбъекта, "ПланОбмена") = 0 Тогда 
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьУзел();
	КонецЕсли;
		
	Возврат Неопределено; 
КонецФункции
 
&НаСервере
Функция СоздатьГруппу(ДанныеФайла)
	Если СтрСравнить(ДанныеФайла.ТипОбъекта, "Справочник") = 0 и ДанныеФайла.мдОбъекта.Иерархический 
		и ДанныеФайла.мдОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов 
	Тогда
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьГруппу();
	ИначеЕсли СтрСравнить(ДанныеФайла.ТипОбъекта, "ПланВидовХарактеристик") = 0 и ДанныеФайла.мдОбъекта.Иерархический Тогда
		Возврат ДанныеФайла.МенеджерОбъекта.СоздатьГруппу();
	КонецЕсли;
	
	Возврат Неопределено; 
КонецФункции

&НаСервере
Функция ПреобразоватьДанныеФайлов()
	Если не ЗначениеЗаполнено(ДанныеФайловВХ) Тогда
		ДобавитьСобытиеВПротоколСервер("Ошибка", "Е30",,,,
			НСтр("ru='Адрес временного хранилища с данными файлов Excel не указан.'"),
			РезультатПротокол().Остановка); 
		Возврат Ложь; 
	КонецЕсли; 
	мДанныеФайлов = ПолучитьИзВременногоХранилища(ДанныеФайловВХ);
	
	Если ТипЗнч(мДанныеФайлов) <> Тип("Массив") Тогда
		ДобавитьСобытиеВПротоколСервер("Ошибка", "Е31",,,,
			НСтр("ru='Неправильный формат данных временного хранилища.'"),
			РезультатПротокол().Остановка); 
			
		УдалитьИзВременногоХранилища(ДанныеФайловВХ);
		Возврат Ложь; 
	КонецЕсли; 
	
	ДанныеФайловТЗ = СоздатьСтруктуруТЗДанныхФайлов();
	Для каждого элДанныеФайла Из мДанныеФайлов Цикл
		Успех = ДобавитьДанныеФайлаВТЗ(ДанныеФайловТЗ, элДанныеФайла);
		Если не Успех и ОстановкаПоОшибке Тогда
			УдалитьИзВременногоХранилища(ДанныеФайловВХ);
			Возврат Ложь; 
		КонецЕсли;
	КонецЦикла;
	
	ПоместитьВоВременноеХранилище(ДанныеФайловТЗ, ДанныеФайловВХ);
	Возврат Истина; 
КонецФункции

&НаСервере
Функция ДобавитьДанныеФайлаВТЗ(ТЗ, элДанныеФайла)
	стрТЗ = ТЗ.Добавить();
	ЗаполнитьЗначенияСвойств(стрТЗ, элДанныеФайла, "ИмяФайла, ИмяОбъекта, ИмяТЧ, ДанныеНомерПервойСтроки, ОписаниеНомерПервойСтроки");
	
	ДобавитьСобытиеВПротоколСервер(
		"Информация",
		"Е107",
		стрТЗ.ИмяОбъекта,
		стрТЗ.ИмяТЧ,,
		СтрШаблон(НСтр("ru='Преобразование данных файла ""%1""...'"), стрТЗ.ИмяФайла)
	);
	
	МожетИметьТЧ = Ложь;
	ДанныеОшибки = Неопределено;
	стрТЗ.мдОбъекта = ПолучитьМетаданныеИМенеджерОбъекта(стрТЗ.ИмяОбъекта, стрТЗ.ТипОбъекта, стрТЗ.ВидОбъекта, стрТЗ.МенеджерОбъекта, ДанныеОшибки, МожетИметьТЧ, Истина);
	
	Если ДанныеОшибки <> Неопределено Тогда
		ДанныеОшибки.Вставить("Пропуск", "ФайлПропущенИлиОстановка");
		ДобавитьСообщениеВЛогИзСтруктуры(ДанныеОшибки, "Е106",стрТЗ);
		ТЗ.Удалить(стрТЗ);
		Возврат Ложь; 
	КонецЕсли; 
	
	стрТЗ.ОбъектныйТип = (ПолучитьСтандартныйРеквизит(стрТЗ.мдОбъекта, "Ссылка") <> Неопределено);
	стрТЗ.КолонкиДанных = Новый Структура;
	стрТЗ.ДопСвойства = Новый Структура;
	
	Если ЗначениеЗаполнено(стрТЗ.ИмяТЧ) Тогда
		Если МожетИметьТЧ = Ложь или стрТЗ.мдОбъекта.ТабличныеЧасти.Найти(стрТЗ.ИмяТЧ) = Неопределено Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Ошибка",
				"Е35",
				стрТЗ.ИмяОбъекта,
				стрТЗ.ИмяТЧ,,
				СтрШаблон(НСтр("ru='В файле ""%1"" указано некорректное имя табличной части - ""%2"".'"), стрТЗ.ИмяФайла, стрТЗ.ИмяТЧ),
				?(не ОстановкаПоОшибке,
					РезультатПротокол().ФайлПропущен,
					РезультатПротокол().Остановка
				)
			);
			ТЗ.Удалить(стрТЗ);
			Возврат Ложь; 
		КонецЕсли;
		стрТЗ.мдОбъектаИлиТЧ = стрТЗ.мдОбъекта.ТабличныеЧасти[стрТЗ.ИмяТЧ];
	Иначе
		стрТЗ.мдОбъектаИлиТЧ = стрТЗ.мдОбъекта;
	КонецЕсли;
			
	//Описание
	стрТЗ.Описание = СоздатьСтруктуруТЗОписание();
	
	ИндексСтроки = 0;
	Для каждого элОписание Из элДанныеФайла.ЕОписание Цикл
		Если не ДобавитьОписаниеФайлаВТЗ(стрТЗ, элОписание, ИндексСтроки) Тогда
			Если ОстановкаПоОшибке Тогда
				ТЗ.Удалить(стрТЗ);
				Возврат Ложь; 
			КонецЕсли; 
		КонецЕсли;
		ИндексСтроки = ИндексСтроки + 1;
	КонецЦикла; 
	
	//Данные
	стрТЗ.Данные = СформироватьСтруктуруТаблицыДанных(стрТЗ, элДанныеФайла.ЕДанные);
	Если стрТЗ.Данные = Неопределено Тогда
		ТЗ.Удалить(стрТЗ);
		Возврат Ложь; 
	КонецЕсли; 
	ЗаполнитьТаблицуДанных(стрТЗ, стрТЗ.Данные);
	
	//ПреобразоватьДанныеФайла(стрТЗ);
	
	Возврат Истина;
КонецФункции

&НаСервере
Функция ПолучитьМетаданныеИМенеджерОбъекта(знач ИмяОбъекта, ТипОбъекта, ВидОбъекта, МенеджерОбъекта, ДанныеОшибки, МожетИметьТЧ, ТолькоЗагружаемые)
	
	Перем мдТипа;
	ДанныеОшибки = Неопределено;
	КодОшибки = Неопределено;
	
	Если ТипЗнч(ИмяОбъекта) = Тип("Строка") Тогда
		МасТипВид = СтрРазделить(ИмяОбъекта,".", Истина);
		Если МасТипВид.Количество() <> 2 Тогда
			КодОшибки = "Е32";
		Иначе
			ТипОбъекта = СокрЛП(МасТипВид[0]);
			ВидОбъекта = СокрЛП(МасТипВид[1]);
		КонецЕсли;
	Иначе
		ИмяОбъекта = ТипОбъекта+"."+ВидОбъекта;
	КонецЕсли; 
	
	Если КодОшибки = Неопределено Тогда
		МенеджерТипа = Неопределено;
		мдТипа = ПолучитьМетаданныеИМенеджерТипа(ТипОбъекта, МенеджерТипа, МожетИметьТЧ, ТолькоЗагружаемые);
		Если мдТипа = Неопределено Тогда
			КодОшибки = "Е33";
		КонецЕсли;
	КонецЕсли; 
	
	Если КодОшибки = Неопределено Тогда
		мдОбъекта = мдТипа.Найти(ВидОбъекта);
		Если мдОбъекта = Неопределено Тогда
			КодОшибки = "Е34";
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(КодОшибки) Тогда
		ДанныеОшибки = Новый Структура("Текст, Код",
			СтрШаблон(НСтр("ru='Некорректный тип/вид объекта - ""%1"".'"), ИмяОбъекта),
			КодОшибки);
		Возврат Неопределено;
	КонецЕсли;
			
	МенеджерОбъекта = МенеджерТипа[ВидОбъекта]; 
	Возврат мдОбъекта;
	
КонецФункции 

&НаСервере
Процедура ЗаписатьСоответствиеОбъектаПоID(знач Источник, знач Таблица, знач ID, знач СсылкаОбъекта, знач ЗаписыватьВоВременныйКэш = Ложь)	
	Если СтрДлина(ID) > ДлинаID Тогда
		ВызватьИсключение СтрШаблон(
			НСтр("ru='Внутренняя ошибка: Длина идентификатора (""%1"") для записываемого соответствия больше длины идентификатора в измерении регистра (%2)'"),
			ID,
			ДлинаID); 
	КонецЕсли;
	
	Если ЗаписыватьВоВременныйКэш = Истина или ЕстьРегистрСоответствияОбъектов = Ложь Тогда
		Если ТипЗнч(сКэшСоответствийОбъекта) <> Тип("ТаблицаЗначений") Тогда
			сКэшСоответствийОбъекта = СоздатьСтруктуруКэшаСоответствийОбъекта();
		КонецЕсли;
		
		стрНайдено = сКэшСоответствийОбъекта.НайтиСтроки(Новый Структура("Источник, Таблица, ID", Источник, Таблица, ID));
		Если стрНайдено.Количество() = 0 Тогда
			стр = сКэшСоответствийОбъекта.Добавить();
			стр.ID = ID;
			стр.Таблица = Таблица;
			стр.Источник = Источник;
		
		Иначе
			стр = стрНайдено[0]; 
		КонецЕсли;
		стр.СсылкаОбъекта = СсылкаОбъекта;
		
	Иначе
		НЗ = РегистрыСведений.ис_СоответствияОбъектовДляЗагрузкиИД.СоздатьНаборЗаписей();
		НЗ.Отбор.ID.Установить(ID);
		НЗ.Отбор.Таблица.Установить(Таблица);
		НЗ.Отбор.Источник.Установить(Источник);
		
		ЗаписьВРегистр = НЗ.Добавить();
		ЗаписьВРегистр.ID = ID;
		ЗаписьВРегистр.Таблица = Таблица;
		ЗаписьВРегистр.Источник = Источник;
		ЗаписьВРегистр.СсылкаОбъекта = СсылкаОбъекта;
				
		НЗ.Записать(Истина);
		
	КонецЕсли; 
	
	
КонецПроцедуры

&НаСервере
Процедура ЗаполнитьТаблицуДанных(стрДанныеФайла, ТЗДанные)
	КолонкиСДанными = стрДанныеФайла.ДопСвойства.Врем_КолонкиСДанными;
	
	// считаем количество строк с данными для создания ТЗ
	КолСтрок = 0;
	Для каждого КолонкаСДанными Из КолонкиСДанными Цикл
		КолСтрок = Макс(КолонкаСДанными.Значение.Количество(), КолСтрок);
	КонецЦикла;
	
	Для сч=1 По КолСтрок Цикл
    	ТЗДанные.Добавить();
	КонецЦикла;
	
	Для каждого КолонкаСДанными Из КолонкиСДанными Цикл
		ТЗДанные.ЗагрузитьКолонку(КолонкаСДанными.Значение, КолонкаСДанными.Ключ);
	КонецЦикла;
	
	// Удаляем первую строку - в ней содержатся заголовки колонок
	Если КолСтрок > 0 Тогда
		ТЗДанные.Удалить(0);
	КонецЕсли; 
	
	// удаляем последние полностью пустые строки
	ТекИндекс = ТЗДанные.Количество();
	Пока ТекИндекс > 0 Цикл
		ТекИндекс = ТекИндекс - 1;
		ТекСтрока = ТЗДанные[ТекИндекс];
		ПустаяСтрока = Истина;
		Для каждого КолонкаСДанными Из КолонкиСДанными Цикл
			Если ЗначениеЗаполнено(ТекСтрока[КолонкаСДанными.Ключ]) Тогда
				ПустаяСтрока = Ложь;
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		Если ПустаяСтрока Тогда
			ТЗДанные.Удалить(ТекСтрока);
		Иначе
			// строка не пустая - дальше не проверяем.
			Прервать;
		КонецЕсли; 
	КонецЦикла; 
	
	стрДанныеФайла.ДопСвойства.Удалить("Врем_КолонкиСДанными");
КонецПроцедуры 

&НаСервере
Функция СформироватьСтруктуруТаблицыДанных(стрДанныеФайла, ЕДанные)
	стрДанныеФайла.ДопСвойства.Вставить("Врем_КолонкиСДанными", Новый Структура);
	ТЗ = Новый ТаблицаЗначений;
	Если ТипЗнч(ЕДанные) <> Тип("Массив") Тогда
		ДобавитьСобытиеВПротоколСервер(
			"Ошибка",
			"Е39",
			стрДанныеФайла.ИмяОбъекта,
			стрДанныеФайла.ИмяТЧ,
			,
			НСтр("ru='Неверный формат диапазона с данными, полученный из файла Excel ""%1"".'"),
			?(не ОстановкаПоОшибке,
				РезультатПротокол().ФайлПропущен,
				РезультатПротокол().Остановка
			)
		);
		Возврат Неопределено; 
	КонецЕсли; 
	Для каждого ЕКолонкаДанных Из ЕДанные Цикл
		Если ТипЗнч(ЕКолонкаДанных) <> Тип("Массив") или ЕКолонкаДанных.Количество()=0 Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Ошибка",
				"Е40",
				стрДанныеФайла.ИмяОбъекта,
				стрДанныеФайла.ИмяТЧ,
				,
				НСтр("ru='Неверный формат диапазона с данными, полученный из файла Excel ""%1"".'"),
				?(не ОстановкаПоОшибке,
					РезультатПротокол().ФайлПропущен,
					РезультатПротокол().Остановка
				)
			);
			Возврат Неопределено; 
		КонецЕсли;
		
		ИмяКолонки = ЕКолонкаДанных[0];
		Если не ЗначениеЗаполнено(ИмяКолонки) Тогда
			// пропускаем данную колонку
			ДобавитьСобытиеВПротоколСервер(
				"Предупреждение",
				"Е41",
				стрДанныеФайла.ИмяОбъекта,
				стрДанныеФайла.ИмяТЧ,
				,
				НСтр("ru='На листе ""Данные"" найдена колонка без имени.'"),
				НСтр("ru='Данные указанной колонки не будут загружены.'")); 
			Продолжить;
		КонецЕсли;
		
		Если ЭтоСистемнаяКолонка(ИмяКолонки) Тогда
			Если ПолучитьДопустимостьОбязательностьСистемнойКолонки(ИмяКолонки, стрДанныеФайла)=Ложь Тогда
				// такая колонка не допустима
				ДобавитьСобытиеВПротоколСервер(
					"Ошибка",
					"Е47",
					стрДанныеФайла.ИмяОбъекта,
					стрДанныеФайла.ИмяТЧ,
					,
					СтрШаблон(НСтр("ru='На листе ""Данные"" найдена недопустимая системная колонка ""%1"".'"),ИмяКолонки),
					?(не ОстановкаПоОшибке,
						РезультатПротокол().КолонкаПропущена,
						РезультатПротокол().Остановка
					)
					
				); 
				
				Если не ОстановкаПоОшибке Тогда
					Продолжить;
				Иначе
					Возврат Неопределено; 
				КонецЕсли; 
			КонецЕсли; 
			
			ИмяКолонкиТЗ = ИмяСистемнойКолонки(ИмяКолонки, стрДанныеФайла);
		Иначе // не системная колонка на листе Данные
			
			КолонкаОписание = стрДанныеФайла.Описание.Найти(ВРег(ИмяКолонки), "ИмяКолонкиДанные_Врег");
			Если КолонкаОписание = Неопределено Тогда
				ДобавитьСобытиеВПротоколСервер(
					"Предупреждение",
					"Е42",
					стрДанныеФайла.ИмяОбъекта,
					стрДанныеФайла.ИмяТЧ,
					,
					СтрШаблон(НСтр("ru='Колонка ""%1"", указанная на листе ""Данные"", не найдена на листе ""Описание"".'"), ИмяКолонки),
					НСтр("ru='Данные указанной колонки не будут загружены.'")); 
				Продолжить; 
			КонецЕсли;
			
			Если ПустаяСтрока(КолонкаОписание.Имя1С) Тогда
				// колонки с неуказанным именем 1С не загружаем.
				Продолжить;
			КонецЕсли; 
			
			Если КолонкаОписание.ПрисутствуетНаЛистеДанные = Истина Тогда
				
				
				Если не ОстановкаПоОшибке Тогда
					ДобавитьСобытиеВПротоколСервер(
						"Предупреждение",
						"Е46",
						стрДанныеФайла.ИмяОбъекта,
						стрДанныеФайла.ИмяТЧ,
						,
						СтрШаблон(
							НСтр("ru='Колонка ""%1"" встречается на листе ""Данные"" повторно.'"), 
							КолонкаОписание.ИмяКолонкиДанные),
						СтрШаблон(
							НСтр("ru='Будут загружены данные только самой левой колонки ""%1"".'"),
							КолонкаОписание.ИмяКолонкиДанные));
					
					Продолжить;
				Иначе
					ДобавитьСобытиеВПротоколСервер(
						"Ошибка",
						"Е45",
						стрДанныеФайла.ИмяОбъекта,
						стрДанныеФайла.ИмяТЧ,
						,
						НСтр("ru='Колонка ""%1"" встречается на листе ""Данные"" повторно. Непонятно, из какой колонки загружать данные.'"),
						?(не ОстановкаПоОшибке,
							РезультатПротокол().ФайлПропущен,
							РезультатПротокол().Остановка
						)
					);
					
					Возврат Неопределено; 
				КонецЕсли; 
			КонецЕсли; 
			
			КолонкаОписание.ПрисутствуетНаЛистеДанные = Истина;
			ИмяКолонкиТЗ = КолонкаОписание.Имя1С;
			стрДанныеФайла.КолонкиДанных.Вставить(ИмяКолонкиТЗ, КолонкаОписание);
		КонецЕсли; // не системная колонка на листе Данные
		
		стрДанныеФайла.ДопСвойства.Врем_КолонкиСДанными.Вставить(ИмяКолонкиТЗ, ЕКолонкаДанных);
		ТЗ.Колонки.Добавить(ИмяКолонкиТЗ);
		
	КонецЦикла;
	
	ТЗ.Колонки.Добавить("__Обработано", Новый ОписаниеТипов("Булево"));
	
	//////////////////////////////////////////////////////////////////////////
	// дополнительные проверки
		
	// Для ТЧ проверка наличия колонки "Ссылка" в таблице данных
	Если ЗначениеЗаполнено(стрДанныеФайла.ИмяТЧ) Тогда
		ИмяКолонкиСсылка = ИмяСистемнойКолонки("Ссылка", стрДанныеФайла);
		
		// проверяем наличие колонки "Ссылка" в таблице данных. Это системная колонка, на листе "Описание" её нет
		Если ТЗ.Колонки.Найти(ИмяКолонкиСсылка) = Неопределено Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Ошибка",
				"Е83",
				стрДанныеФайла.ИмяОбъекта,
				стрДанныеФайла.ИмяТЧ,
				,
				СтрШаблон(
					НСтр("ru='В файле ""%1"" отсутствует обязательная колонка ""Ссылка"".'"),
					стрДанныеФайла.ИмяФайла
				),
				РезультатПротокол("ФайлПропущенИлиОстановка")
			);
			Возврат Неопределено; 
		КонецЕсли;
	КонецЕсли; 
	
	// для регистров проверка, что все колонки с отбором присутствуют на листе Данные 
	// проверка, что для зависимого регистра отбор - только регистратор
	РегистрПодчиненРегистратору = Ложь;
	ЭтоРегистрБухгалтерии = Ложь;
	ЭтоРегистр = ПолучитьАтрибутыРегистра(стрДанныеФайла.ТипОбъекта, стрДанныеФайла.мдОбъекта,, РегистрПодчиненРегистратору,ЭтоРегистрБухгалтерии,,); 
	
	// у регистра подчиненного регистратору должна быть колонка "Регистратор" 
	Если РегистрПодчиненРегистратору Тогда
		КолонкаРегистратор = Неопределено;
		стрДанныеФайла.КолонкиДанных.Свойство("Регистратор", КолонкаРегистратор);
		Если КолонкаРегистратор = Неопределено Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Ошибка",
				"Е90",
				стрДанныеФайла.ИмяОбъекта,
				стрДанныеФайла.ИмяТЧ,
				,
				НСтр("ru='Отсутствует колонка с именем 1С ""Регистратор"", хотя данный регистр подчинен регистратору.'"),
				РезультатПротокол("ФайлПропущенИлиОстановка"),
				""
			);
			Возврат Неопределено; 
		КонецЕсли; 
	КонецЕсли; 
	
	Для каждого стрОписание Из стрДанныеФайла.Описание Цикл
		
		// проверка того, что для регистра бухгалтерии в случае наличия колонки СубконтоХДК есть колонка СчетДК, производится на этапе формирования таблицы Описание для данного файла.
		Если ЭтоРегистр Тогда
			Если ЭтоРегистрБухгалтерии Тогда
				Если стрОписание.НомерСубконто > 0 и стрОписание.ПрисутствуетНаЛистеДанные = Истина Тогда
					// колонка с субконто
					Направление = Прав(стрОписание.Имя1С,2);
					ИмяБазовогоПоля = "Счет"+Направление;
					ОписаниеСчетНайдено = Неопределено;
					стрДанныеФайла.КолонкиДанных.Свойство(ИмяБазовогоПоля, ОписаниеСчетНайдено);
					Если ОписаниеСчетНайдено = Неопределено или ОписаниеСчетНайдено.ПрисутствуетНаЛистеДанные = Ложь Тогда
						ДобавитьСобытиеВПротоколСервер(
							"Ошибка",
							"Е82",
							стрДанныеФайла.ИмяОбъекта,
							стрДанныеФайла.ИмяТЧ,
							,
							СтрШаблон(
								НСтр("ru='Для колонки ""%1"" на листе ""Данные"" отсутствует ведущая колонка с именем 1С ""%2"". Выполнить загрузку значений из колонки ""%1"" будет невозможно.'"),
								стрОписание.ИмяКолонкиДанные, ИмяБазовогоПоля
							),
							РезультатПротокол("ФайлПропущенИлиОстановка"),
							стрОписание.Имя1С
						);
						Возврат Неопределено; 
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
			
			// проверка, что для зависимого регистра отбор - только регистратор
			Если РегистрПодчиненРегистратору и стрОписание.ПолеОтбора <> (стрОписание.Имя1С_ВРег = "РЕГИСТРАТОР") Тогда
				ДобавитьСобытиеВПротоколСервер(
					"Предупреждение",
					"Е89",
					стрДанныеФайла.ИмяОбъекта,
					стрДанныеФайла.ИмяТЧ,
					,
					СтрШаблон(
						НСтр("ru='Регистр, подчиненный регистратору, должен иметь в качестве поля отбора только колонку с именем 1С ""Регистратор"".'"),
						стрОписание.ИмяКолонкиДанные
					),
					НСтр("ru='Поле отбора установлено принудительно в соответствии с указанным правилом'"),
					стрОписание.Имя1С
				);
				стрОписание.ПолеОтбора = (стрОписание.Имя1С_ВРег = "РЕГИСТРАТОР");
			КонецЕсли; 
			// для регистров проверка, что все колонки с отбором присутствуют на листе Данные 
			Если стрОписание.ПолеОтбора и стрОписание.ПрисутствуетНаЛистеДанные = Ложь Тогда
				ДобавитьСобытиеВПротоколСервер(
					"Ошибка",
					"Е88",
					стрДанныеФайла.ИмяОбъекта,
					стрДанныеФайла.ИмяТЧ,
					,
					СтрШаблон(
						НСтр("ru='Колонка ""%1"" указана как колонка отбора, но на листе ""Данные"" она отсутствует.'"),
						стрОписание.ИмяКолонкиДанные
					),
					РезультатПротокол("ФайлПропущенИлиОстановка"),
					стрОписание.Имя1С
				);
				Возврат Неопределено; 
			КонецЕсли; 
		КонецЕсли; 
		
		// вывод предупреждения для колонок, которые есть в описании, но отсутствуют в ТЗ
		Если стрОписание.ПрисутствуетНаЛистеДанные = Ложь и ЗначениеЗаполнено(стрОписание.Имя1С) Тогда
			Если стрОписание.ПроверятьЗаполнение = Истина Тогда
				ДобавитьСобытиеВПротоколСервер(
					"Ошибка",
					"Е48",
					стрДанныеФайла.ИмяОбъекта,
					стрДанныеФайла.ИмяТЧ,
					,
					СтрШаблон(
						НСтр("ru='Обязательная колонка ""%1"" встречается на листе ""Описание"", но отсутствует на листе ""Данные"".'"),
						стрОписание.ИмяКолонкиДанные),
					?(не ОстановкаПоОшибке,
						РезультатПротокол().ФайлПропущен,
						РезультатПротокол().Остановка
					)
				);
				
				Возврат Неопределено;
			Иначе
				ДобавитьСобытиеВПротоколСервер(
					"Предупреждение",
					"Е49",
					стрДанныеФайла.ИмяОбъекта,
					стрДанныеФайла.ИмяТЧ,
					,
					СтрШаблон(НСтр("ru='Колонка ""%1"" встречается на листе ""Описание"", но отсутствует на листе ""Данные"".'"), стрОписание.ИмяКолонкиДанные),
					СтрШаблон(НСтр("ru='Реквизит ""%1"" не будет заполняться'"), стрОписание.Имя1С)
				);
				
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла; 
	Возврат ТЗ; 	
КонецФункции

&НаСервереБезКонтекста
Функция ЭтоСистемнаяКолонка(ИмяКолонки)
	Возврат Найти("|ID|REF|ССЫЛКА|", "|"+ВРег(ИмяКолонки)+"|") > 0; 
КонецФункции
 
&НаСервере
Функция ДобавитьОписаниеФайлаВТЗ(стрДанныеФайла, элОписание, ИндексСтроки)
	Если не ЗначениеЗаполнено(элОписание.ИмяКолонкиДанные) Тогда
		// сообщение не выводим, поскольку эта проверка уже выполнялась при чтении из Экселя непосредственно.
		Возврат Истина;
	КонецЕсли; 
	
	СтрНайдено = стрДанныеФайла.Описание.Найти(ВРег(элОписание.ИмяКолонкиДанные), "ИмяКолонкиДанные_Врег");
	Если СтрНайдено <> Неопределено Тогда
		ОшибкаРазбораЛистаОписания(
			стрДанныеФайла,ИндексСтроки, "Е43",
			СтрШаблон(НСтр("ru='На листе ""Описание"" колонка ""%1"" указана более одного раза.'"), элОписание.ИмяКолонкиДанные));
		Возврат Ложь; 	
	КонецЕсли;
	Если ЗначениеЗаполнено(элОписание.Имя1С) Тогда
		СтрНайдено = стрДанныеФайла.Описание.Найти(ВРег(элОписание.Имя1С), "Имя1С_Врег");
		Если СтрНайдено <> Неопределено Тогда
			ОшибкаРазбораЛистаОписания(
				стрДанныеФайла,ИндексСтроки, "Е44",
				СтрШаблон(НСтр("ru='На листе ""Описание"" имя 1С ""%1"" указано более одного раза.'"), элОписание.Имя1С));
			Возврат Ложь; 	
		КонецЕсли; 
	КонецЕсли; 
	
	ОписаниеКолонка = стрДанныеФайла.Описание.Добавить();
	ЗаполнитьЗначенияСвойств(ОписаниеКолонка, элОписание, "ИмяКолонкиДанные, Имя1С, ОсновнойПоиск");
	ОписаниеКолонка.ИмяКолонкиДанные_Врег = ВРег(ОписаниеКолонка.ИмяКолонкиДанные);
	ОписаниеКолонка.Имя1С_Врег = ВРег(ОписаниеКолонка.Имя1С);
	
	Если не ПреобразоватьВЗначениеБулево(ОписаниеКолонка.ПроверятьЗаполнение, элОписание.ПроверятьЗаполнение, Ложь) Тогда
		ОшибкаРазбораЛистаОписания(
			стрДанныеФайла,ИндексСтроки, "Е36",
			НСтр("ru='На листе ""Описание"" в колонке ""Проверка заполнения"" указано значение, не являющееся логическим.'"));
			
		стрДанныеФайла.Описание.Удалить(ОписаниеКолонка);	
		Возврат Ложь; 
	КонецЕсли;
	
	Если СтрСравнить(стрДанныеФайла.ТипОбъекта, "РегистрСведений")=0 Тогда
		Если не ПреобразоватьВЗначениеБулево(ОписаниеКолонка.ПолеОтбора, элОписание.ПолеОтбора, Ложь) Тогда
			ОшибкаРазбораЛистаОписания(
				стрДанныеФайла,ИндексСтроки, "Е37",
				НСтр("ru='На листе ""Описание"" в колонке ""Поле отбора"" указано значение, не являющееся логическим.'"));
				
			стрДанныеФайла.Описание.Удалить(ОписаниеКолонка);	
			Возврат Ложь; 
				
		КонецЕсли;
	КонецЕсли;
	
	мдРеквизит = Неопределено;
	Если не СуществуетРеквизитОбъекта(стрДанныеФайла.мдОбъекта, стрДанныеФайла.ТипОбъекта, стрДанныеФайла.ИмяТЧ, ОписаниеКолонка.Имя1С, Ложь, мдРеквизит, ОписаниеКолонка) Тогда
			ОшибкаРазбораЛистаОписания(
				стрДанныеФайла,
				ИндексСтроки, 
				"Е38",
				СтрШаблон(
					НСтр("ru='На листе ""Описание"" в колонке ""Имя 1С"" указано имя ""%1"", не являющееся именем реквизита.'"),
					ОписаниеКолонка.Имя1С
				)
			);
			
			стрДанныеФайла.Описание.Удалить(ОписаниеКолонка);	
			Возврат Ложь; 
	КонецЕсли; 
	
	ОписаниеКолонка.Тип = мдРеквизит.Тип;
	Возврат Истина; 
КонецФункции
	
&НаСервереБезКонтекста
Функция ПолучитьМетаданныеИМенеджерТипа(знач ТипОбъекта,  МенеджерТипа, МожетИметьТЧ, знач ТолькоЗагружаемые = Истина)
	
	мдТипа = Неопределено;
	МенеджерТипа = Неопределено;
	
	Если СтрСравнить(ТипОбъекта, "Справочник") = 0 Тогда
		МенеджерТипа = Справочники;
		МожетИметьТЧ = Истина;
		мдТипа = Метаданные.Справочники;
	ИначеЕсли СтрСравнить(ТипОбъекта, "Документ") = 0 Тогда 
		МенеджерТипа = Документы;
		МожетИметьТЧ = Истина;
		мдТипа = Метаданные.Документы;
	ИначеЕсли СтрСравнить(ТипОбъекта, "Перечисление") = 0 и ТолькоЗагружаемые = Ложь Тогда
		МенеджерТипа = Перечисления;
		МожетИметьТЧ = Ложь;
		мдТипа = Метаданные.Перечисления;
	ИначеЕсли СтрСравнить(ТипОбъекта, "ПланВидовХарактеристик") = 0 Тогда 
		МожетИметьТЧ = Истина;
		МенеджерТипа = ПланыВидовХарактеристик;
		мдТипа = Метаданные.ПланыВидовХарактеристик;
	ИначеЕсли СтрСравнить(ТипОбъекта, "ПланСчетов") = 0 и ТолькоЗагружаемые = Ложь Тогда 
		МожетИметьТЧ = Истина;
		МенеджерТипа = ПланыСчетов;
		мдТипа = Метаданные.ПланыСчетов;
	ИначеЕсли СтрСравнить(ТипОбъекта, "ПланВидовРасчета") = 0 и ТолькоЗагружаемые = Ложь Тогда 
		МожетИметьТЧ = Истина;
		МенеджерТипа = ПланыСчетов;
		мдТипа = Метаданные.ПланыВидовРасчета;
	ИначеЕсли СтрСравнить(ТипОбъекта, "РегистрСведений") = 0 Тогда 
		МожетИметьТЧ = Ложь;
		МенеджерТипа = РегистрыСведений;
		мдТипа = Метаданные.РегистрыСведений;
	ИначеЕсли СтрСравнить(ТипОбъекта, "РегистрНакопления") = 0 Тогда 
		МожетИметьТЧ = Ложь;
		МенеджерТипа = РегистрыНакопления;
		мдТипа = Метаданные.РегистрыНакопления;
	ИначеЕсли СтрСравнить(ТипОбъекта, "РегистрБухгалтерии") = 0 Тогда 
		МожетИметьТЧ = Ложь;
		МенеджерТипа = РегистрыБухгалтерии;
		мдТипа = Метаданные.РегистрыБухгалтерии;
		
	// в настоящий момент загрузку не поддерживаем	
	//ИначеЕсли СтрСравнить(ТипОбъекта, "РегистрРасчета") = 0 Тогда 
	//	МожетИметьТЧ = Ложь;
	//	МенеджерОбъекта = РегистрыРасчета;
	//	мдТипа = Метаданные.РегистрыРасчета;
		
	ИначеЕсли СтрСравнить(ТипОбъекта, "БизнесПроцесс") = 0 и ТолькоЗагружаемые = Ложь Тогда 
		МожетИметьТЧ = Истина;
		МенеджерТипа = БизнесПроцессы;
		мдТипа = Метаданные.БизнесПроцессы;
		
	ИначеЕсли СтрСравнить(ТипОбъекта, "Задача") = 0 и ТолькоЗагружаемые = Ложь Тогда 
		МожетИметьТЧ = Истина;
		МенеджерТипа = Задачи;
		мдТипа = Метаданные.Задачи;
		
	ИначеЕсли СтрСравнить(ТипОбъекта, "ПланОбмена") = 0 и ТолькоЗагружаемые = Ложь Тогда 
		МожетИметьТЧ = Истина;
		МенеджерТипа = ПланыОбмена;
		мдТипа = Метаданные.ПланыОбмена;
	Иначе
		Возврат Ложь; 
	КонецЕсли;
		
	Возврат мдТипа; 
КонецФункции

// Истина - обязательная, Неопределено - допустимая, но не обязательная, Ложь - недопустимая
&НаСервере
Функция ПолучитьДопустимостьОбязательностьСистемнойКолонки(ИмяКолонки, стрДанныеФайла)
	Если РежимОбработки = "Удаление" Тогда
		Возврат Неопределено; 
	ИначеЕсли РежимОбработки = "РегистрацияСоответствий" Тогда
		Если СтрСравнить(ИмяКолонки, "ID") = 0 или СтрСравнить(ИмяКолонки, "Ссылка") = 0 Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь; 
		КонецЕсли;  
	ИначеЕсли РежимОбработки = "Загрузка" Тогда 
		Если СтрСравнить(ИмяКолонки, "ID") = 0 или СтрСравнить(ИмяКолонки, "Ref") = 0 Тогда
			Если стрДанныеФайла.ОбъектныйТип и ПустаяСтрока(стрДанныеФайла.ИмяТЧ) Тогда
				Возврат Неопределено;
			Иначе
				Возврат Ложь; 
			КонецЕсли; 
		ИначеЕсли СтрСравнить(ИмяКолонки, "Ссылка") = 0 Тогда 
			Возврат ЗначениеЗаполнено(стрДанныеФайла.ИмяТЧ);
		КонецЕсли;
	КонецЕсли; 
	
	Возврат Ложь; 
	
 КонецФункции

 &НаСервере
Функция ПроверитьДлинуID(ID)	
	Возврат ?(СтрДлина(ID) <= ДлинаID, Истина, Ложь);
КонецФункции

#КонецОбласти 

#Область ПреобразованиеЗначений

&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьПредопределенноеЗначениеБезопасно(Результат, Выражение, ДанныеОшибки)
	ДанныеОшибки = Неопределено;
	Попытка
		Результат = ПредопределенноеЗначение(Выражение); 
	Исключение
		ДанныеОшибки = Истина;
	КонецПопытки; 
	
	Если ДанныеОшибки = Истина Тогда
		ДанныеОшибки = Новый Структура("Текст, Код",
			СтрШаблон(НСтр("ru='Предопределенное значение ""%1"" не существует'"), Выражение),
			"Е73"
		);
		Возврат Ложь; 
	КонецЕсли; 
	
	Возврат Истина; 
КонецФункции
 
&НаСервере
Функция ПолучитьСсылкуПоID(знач Источник, знач ИмяОбъекта, знач ID, ДанныеОшибки)	
	ДанныеОшибки = Неопределено;
	Если НЕ ПроверитьДлинуID(ID) Тогда
		ДанныеОшибки = Новый Структура("Текст, Код", 
			СтрШаблон(
				НСтр("ru='Длина идентификатора для получаемой ссылки ""%1"" больше длины идентификатора в измерении регистра (%2)'"),
				ID, ДлинаID
			),
			"Е64"
		);
		
		Возврат Неопределено; 
	КонецЕсли; 
	
	Если ТипЗнч(сКэшСоответствийОбъекта) = Тип("ТаблицаЗначений") Тогда
		стрНайдено = сКэшСоответствийОбъекта.НайтиСтроки(Новый Структура("Источник, Таблица, ID", Источник, ИмяОбъекта, ID));
		Если стрНайдено.Количество() > 0 Тогда
			Возврат стрНайдено[0].СсылкаОбъекта; 
		КонецЕсли;
	КонецЕсли; 
	
	Результат = Неопределено;
	Если ЕстьРегистрСоответствияОбъектов Тогда
		Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ис_СоответствияОбъектовДляЗагрузкиИД.СсылкаОбъекта КАК СсылкаОбъекта
		|ИЗ
		|	РегистрСведений.ис_СоответствияОбъектовДляЗагрузкиИД КАК ис_СоответствияОбъектовДляЗагрузкиИД
		|ГДЕ
		|	ис_СоответствияОбъектовДляЗагрузкиИД.ID = &ID
		|	И ис_СоответствияОбъектовДляЗагрузкиИД.Таблица = &Таблица
		|	И ис_СоответствияОбъектовДляЗагрузкиИД.Источник = &Источник");
		
		Запрос.УстановитьПараметр("ID",       ID);
		Запрос.УстановитьПараметр("Таблица",  ИмяОбъекта);
		Запрос.УстановитьПараметр("Источник", Объект.Источник);
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Результат = Выборка.СсылкаОбъекта;
		КонецЕсли;
	КонецЕсли; 
	
	Возврат Результат;
КонецФункции 

&НаСервере
Функция ПолучитьСсылкуПоRef(МенеджерТипа, знач Реф, ДанныеОшибки)
	//TODO: Пока распознаем только GUID записанный в формате "b3e2001617ec3f2a11e1912c787ec129". Потом можно сделать и распознавание "787ec129-912c-11e1-b3e2-001617ec3f2a"
	ДанныеОшибки = Неопределено;
	Если СтрДлина(Реф) <> 32 Тогда
		ДанныеОшибки = Новый Структура("Текст, Код",
			СтрШаблон(НСтр("ru='Некорректный формат ссылки ""%1"" - должна быть строка длиной 32 символа.'"), Реф),
			"Е69"
		);
		Возврат Неопределено; 
	КонецЕсли;
	
	Попытка
		УИД = Новый УникальныйИдентификатор(Реф);
	Исключение
		УИД = Неопределено;
	КонецПопытки; 
	Если УИД = Неопределено Тогда
		ДанныеОшибки = Новый Структура("Текст, Код",
			СтрШаблон(НСтр("ru='Неправильный формат GUID-ссылки (""%1"").'"), Реф),
			"Е70"
		);
		Возврат Неопределено; 
	КонецЕсли;
	
	Возврат МенеджерТипа.ПолучитьСсылку(УИД); 
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПреобразоватьВЗначениеБулево(ЗначениеПриемник, знач ЗначениеИсточник, ПустоеЗначениеСчитатьЗначением = Неопределено)
	Если ТипЗнч(ЗначениеИсточник)= Тип("Булево") Тогда
		ЗначениеПриемник = ЗначениеИсточник;
		Возврат Истина; 
	ИначеЕсли не ЗначениеЗаполнено(ЗначениеИсточник) Тогда
		Если ПустоеЗначениеСчитатьЗначением = Неопределено Тогда
			Возврат Ложь; 
		КонецЕсли; 
		ЗначениеПриемник = ПустоеЗначениеСчитатьЗначением;
		Возврат Истина; 
	КонецЕсли;
	
	ЗначениеИсточник = ВРег(СокрЛП(ЗначениеИсточник));
	
	Если Найти("|ИСТИНА|TRUE|ДА|1|", "|"+ЗначениеИсточник+"|") > 0 Тогда
		ЗначениеПриемник = Истина;
		Возврат Истина;
	ИначеЕсли Найти("|ЛОЖЬ|FALSE|НЕТ|0|", "|"+ЗначениеИсточник+"|") > 0 Тогда 
		ЗначениеПриемник = Ложь;
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
		
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьЧислоИзСтроки(Результат, знач ПреобразуемоеЗначение)
	Если ПустаяСтрока(ПреобразуемоеЗначение) Тогда
		Возврат Ложь; 
	КонецЕсли; 
	
	ПреобразуемоеЗначение = СокрЛП(ПреобразуемоеЗначение);
	
	Успех = Истина;
	Попытка
		Результат = Число(ПреобразуемоеЗначение);
	Исключение
		Успех = Ложь;
	КонецПопытки; 
	
	Если Успех Тогда
		Возврат Истина; 
	КонецЕсли; 
	
	Если СтрНайти(ПреобразуемоеЗначение,".") > 0 и СтрНайти(ПреобразуемоеЗначение,",") = 0 Тогда
		ПреобразуемоеЗначение = СтрЗаменить(ПреобразуемоеЗначение, ".", ","); 
	КонецЕсли; 
	
	Успех = Истина;
	Попытка
		Результат = Число(ПреобразуемоеЗначение);
	Исключение
		Успех = Ложь;
	КонецПопытки; 
	
	Возврат Успех; 
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьДатуИзСтроки(Результат, знач ПреобразуемоеЗначение, знач РазделительДаты = ".", знач РазделительВремени = ":")
	Результат = Дата('00010101000000');
	
	ПреобразуемоеЗначение = СокрЛП(ПреобразуемоеЗначение);
	
	Если ПустаяСтрока(ПреобразуемоеЗначение) Тогда
		Результат = Дата('00010101000000');
		Возврат Истина; 
	КонецЕсли;
	
	ЭлементыОбщие = СтрРазделить(ПреобразуемоеЗначение, " ", Ложь);
	КолКомпонентДаты = ЭлементыОбщие.Количество();
	
	Если КолКомпонентДаты <> 1 и КолКомпонентДаты <> 2  Тогда
		Возврат Ложь; 
	КонецЕсли; 
	
	Если КолКомпонентДаты = 2 Тогда
		ЭтоЧеловеческийФормат=Истина;
	Иначе
		Если СтрНайти(ПреобразуемоеЗначение, РазделительДаты) > 0 Тогда
			ЧастьСДатой = ЭлементыОбщие[0]; 
			ЧастьСВременем = Неопределено;
			ЭтоЧеловеческийФормат = Истина;
		ИначеЕсли СтрНайти(ПреобразуемоеЗначение, РазделительВремени) > 0 Тогда 
			ЧастьСВременем = ЭлементыОбщие[0]; 
			ЧастьСДатой = Неопределено;
			ЭтоЧеловеческийФормат = Истина;
		Иначе
			ЭтоЧеловеческийФормат = Ложь;
		КонецЕсли; 
	КонецЕсли; 
	
	Если ЭтоЧеловеческийФормат Тогда
		// работаем с датой - должна быть точно.
		РезДень = 1;
		РезМесяц = 1;
		РезГод = 1;
		РезЧас = 0;
		РезМин = 0;
		РезСек = 0;
		Если ЧастьСДатой <> Неопределено Тогда
			ЭлементыДаты    = СтрРазделить(ЧастьСДатой, РазделительДаты);
			Если ЭлементыДаты.Количество() <> 3 Тогда
				Возврат Ложь; 
			КонецЕсли; 
			
			
			Отказ = (ПолучитьЧислоИзСтроки(РезДень, СокрЛП(ЭлементыДаты[0])) = Ложь);
			Отказ = Отказ или ПолучитьЧислоИзСтроки(РезМесяц, СокрЛП(ЭлементыДаты[1])) = Ложь;
			Отказ = Отказ или ПолучитьЧислоИзСтроки(РезГод, СокрЛП(ЭлементыДаты[2])) = Ложь;
			
			Если Отказ или РезДень <= 0 или РезДень > 31 или РезМесяц < 1 или РезМесяц > 12 или РезГод < 0 или РезГод > 3000 Тогда
				Возврат Ложь; 
			КонецЕсли;
			
			Если РезГод < 100 Тогда //двузначный формат года
				// преобразуем в четырехзначный формат
				
				ТекГод = Год(ТекущаяДата());
				
				НормализованныйГод = Цел(ТекГод/100)*100+РезГод; // получаем год из текущего века с заданными последними цифрами
				Если Макс(НормализованныйГод-ТекГод, ТекГод - НормализованныйГод) <= 50 Тогда
					// если не ушли на расстояние более 50 лет от текущего года, берем из этого века
					РезГод = НормализованныйГод;
				ИначеЕсли НормализованныйГод > ТекГод Тогда
					РезГод = НормализованныйГод - 100;
				Иначе //НормализованныйГод < ТекГод
					РезГод = НормализованныйГод + 100;
				КонецЕсли; 
				
			КонецЕсли; 
			
		КонецЕсли;
		Если ЧастьСВременем <> Неопределено Тогда
			ЭлементыВремени = СтрРазделить(ЭлементыОбщие[1], РазделительВремени);
			
			Если ЭлементыВремени.Количество() < 2 или ЭлементыВремени.Количество() > 3 Тогда
				Возврат Ложь; 
			КонецЕсли; 
			
			Отказ = ПолучитьЧислоИзСтроки(РезЧас, СокрЛП(ЭлементыВремени[0]));
			Отказ = Отказ или ПолучитьЧислоИзСтроки(РезМин, СокрЛП(ЭлементыВремени[1]));
			Если ЭлементыВремени.Количество() = 3 Тогда
				Отказ = Отказ или ПолучитьЧислоИзСтроки(РезСек, СокрЛП(ЭлементыВремени[3]))
			КонецЕсли;
			
			Если Отказ или РезЧас < 0 или РезЧас > 23 или РезМин < 0 или РезМин > 59 или РезСек < 0 или РезСек > 59 Тогда
				Возврат Ложь; 
			КонецЕсли; 
		КонецЕсли;
		
		Попытка
			Результат = Дата(РезГод, РезМесяц, РезДень, РезЧас, РезМин, РезСек);
		Исключение
			Возврат Ложь; 
		КонецПопытки; 
	Иначе
		// Формат 1С - ГГГГММДД[ЧЧММСС]
		Попытка
			Результат = Дата(ПреобразуемоеЗначение);
		Исключение
			Возврат Ложь;
		КонецПопытки; 
	КонецЕсли; 
	
	Возврат Истина; 
				
КонецФункции

&НаСервере
Функция ПолучитьЗначениеПоля(ДанныеФайла, СтрокаДанных, знач ИмяПоляИлиСтрокаОписания, знач УстанавливатьПустоеЗначениеПриЕгоОтсутствии, УстанавливатьЗначение, ДанныеОшибки, Контекст)
	ДанныеОшибки = Неопределено;
	Если ТипЗнч(ИмяПоляИлиСтрокаОписания) = Тип("Строка") Тогда
		СтрокаОписания = Неопределено;
		ДанныеФайла.КолонкиДанных.Свойство(ИмяПоляИлиСтрокаОписания, СтрокаОписания);
	Иначе
		СтрокаОписания = ИмяПоляИлиСтрокаОписания;
	КонецЕсли; 
	
	Если СтрокаОписания = Неопределено Тогда
		ДанныеОшибки = Новый Структура("Текст, Код, Пропуск",
			СтрШаблон(
				НСтр("ru='Внутренняя ошибка при получении значения поля: имя поля ""%1"" отсутствует в файле ""%2"".'"),
				ИмяПоляИлиСтрокаОписания, ДанныеФайла.ИмяФайла
			),
			"Е65",
			"ФайлПропущен"
		);
		Возврат Неопределено; 	
	КонецЕсли;
	
	КонвертируемоеЗначение = СтрокаДанных[СтрокаОписания.Имя1С];
	ЗначениеОтсутствует = Ложь;
	Результат = ПреобразоватьЗначение(КонвертируемоеЗначение, СтрокаОписания.Тип, СтрокаОписания.ОсновнойПоиск, ЗначениеОтсутствует, ДанныеОшибки, Контекст); 
	
	Если УстанавливатьПустоеЗначениеПриЕгоОтсутствии Тогда
		УстанавливатьЗначение = Истина;
		Возврат Результат;
	Иначе
		УстанавливатьЗначение = НЕ ЗначениеОтсутствует;
		Возврат Результат;
	КонецЕсли; 
КонецФункции
 
&НаСервере
Функция ПреобразоватьЗначение(знач ПреобразуемоеЗначение, ОписаниеТипаИлиТип, знач РеквизитПоискаДляСсылочногоТипа, ЗначениеОтсутствует, ДанныеОшибки, Контекст)
	Если ТипЗнч(ОписаниеТипаИлиТип) = Тип("ОписаниеТипов") Тогда
		ОписаниеТипа = ОписаниеТипаИлиТип;
		МасТипов = ОписаниеТипа.Типы();
		КолТипов = МасТипов.Количество();
		Если КолТипов = 1 Тогда
			ТипРезультата = МасТипов[0];
		КонецЕсли; 	
		ОписаниеТипа = ОписаниеТипаИлиТип;
	Иначе //Тип
		КолТипов = 1;
		МасТипов = Неопределено;
		ТипРезультата = ОписаниеТипаИлиТип;
		ОписаниеТипа = Неопределено;
	КонецЕсли; 
	
	ДанныеОшибки = Неопределено;
	ЗначениеОтсутствует = Ложь;
	
	Если ПреобразуемоеЗначение = Неопределено или ПреобразуемоеЗначение = NULL Тогда
		ЗначениеОтсутствует = Истина;
		//Возврат Тип.ПривестиЗначение(ПреобразуемоеЗначение);
		Возврат NULL; 
	КонецЕсли;
	
	ТипПреобразуемогоЗначения = ТипЗнч(ПреобразуемоеЗначение);
	ТипСтрока = Тип("Строка");
	ПреобразуемВСтроку = (КолТипов = 1) и ТипРезультата = ТипСтрока;
	
	Если ТипПреобразуемогоЗначения = ТипСтрока и ПреобразуемоеЗначение="" Тогда
		Если ПреобразуемВСтроку Тогда
			Возврат ПреобразуемоеЗначение;
		Иначе
			ЗначениеОтсутствует = Истина;
			//Возврат Тип.ПривестиЗначение(ПреобразуемоеЗначение); 
			Возврат NULL; 
		КонецЕсли;  
	КонецЕсли; 
	
	ЭтоДиезЗапрос = Ложь;

	Если КолТипов = 1 Тогда
		Отказ = Ложь;
		
		// если тип значения соответствует целевому, берем из него.
		Если ТипРезультата = ТипПреобразуемогоЗначения Тогда
			Возврат ПреобразуемоеЗначение; 
		КонецЕсли; 
		
		// преобразование через строковое представление значения
		ПреобразуемоеЗначение = Строка(ПреобразуемоеЗначение);
		Результат = Неопределено;
		Если ПреобразуемВСтроку Тогда
			Возврат ПреобразуемоеЗначение;
		ИначеЕсли ТипРезультата = Тип("Число") Тогда
			Если ПолучитьЧислоИзСтроки(Результат, ПреобразуемоеЗначение) Тогда
				Возврат Результат;
			Иначе
				Отказ = Истина;
			КонецЕсли; 
		ИначеЕсли ТипРезультата = Тип("Булево") Тогда
			Если ПреобразоватьВЗначениеБулево(Результат, ПреобразуемоеЗначение, Неопределено) Тогда
				Возврат Результат;
			Иначе
				Отказ = Истина;
			КонецЕсли; 
		ИначеЕсли ТипРезультата = Тип("Дата") Тогда
			Если ПолучитьДатуИзСтроки(Результат, ПреобразуемоеЗначение) Тогда
				Возврат Результат;
			Иначе
				Отказ = Истина;
			КонецЕсли; 
		ИначеЕсли ТипРезультата = Тип("Тип") или ТипРезультата = Тип("Неопределено") или ТипРезультата = Тип("NULL") Тогда
			// распознаем по #-формату
			ЭтоДиезЗапрос = Истина;
		ИначеЕсли ТипРезультата = Тип("ВидДвиженияНакопления") Тогда
			// возможно это системное перечисление
			// если логика системных перечислений размножится, есть ф-ия ПолучитьПолноеИмяПредопределенногоЗначения(), можно переделать через неё.
			Если ПолучитьПредопределенноеЗначениеБезопасно(Результат, "ВидДвиженияНакопления."+ПреобразуемоеЗначение, ДанныеОшибки) Тогда
				Возврат Результат;
			Иначе
				Отказ = Истина;
			КонецЕсли; 	
		Иначе // ссылочный простой тип 
			Если Лев(ПреобразуемоеЗначение,1)="#" Тогда
				//#-формат
				ЭтоДиезЗапрос = Истина;
			Иначе
				// простой формат
				Если НайтиЗначениеСсылочногоТипа(Результат, ПреобразуемоеЗначение, ТипРезультата, РеквизитПоискаДляСсылочногоТипа, ДанныеОшибки, Контекст) Тогда
					Возврат Результат;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
		
		Если Отказ Тогда
			ДанныеОшибки = Новый Структура("Текст, Код", 
				СтрШаблон(
					НСтр("ru='Ошибка преобразования значения ""%1"" в тип ""%2"".'"), 
					ПреобразуемоеЗначение, Строка(ТипРезультата)
				),
				"Е66"
			);
		КонецЕсли; 
	Иначе  // КолТипов > 1
		// составной тип - распознаем по #-формату
		ЭтоДиезЗапрос = Истина;
		
	КонецЕсли; 
	
	Если ЭтоДиезЗапрос Тогда
		Если КолТипов = 1 Тогда
			СтрТиповПоУмолчанию = ПреобразоватьТипВСтроку(ТипРезультата);
		Иначе
			СтрТиповПоУмолчанию = "";
		КонецЕсли;
		
		ВыполнитьДиезЗапрос(Результат, ПреобразуемоеЗначение, СтрТиповПоУмолчанию, ДанныеОшибки, Контекст);
		
		Если ДанныеОшибки = Неопределено Тогда
			// проверяем соответствие типа полученного значения типам результата
			Если ОписаниеТипа = Неопределено Тогда
				МасТипов = Новый Массив(1);
				МасТипов[0] = ТипРезультата;
				ОписаниеТипа = Новый ОписаниеТипов(МасТипов);
			КонецЕсли; 
			Если не ОписаниеТипа.СодержитТип(ТипЗнч(Результат)) Тогда
				ДобавитьСобытиеВПротоколСервер(
					"Предупреждение",
					"Е110",
					Контекст.ДанныеФайла.ИмяОбъекта,
					Контекст.ДанныеФайла.ИмяТЧ,
					Контекст.НомерСтроки,
					СтрШаблон(НСтр("ru='Тип значения вычисленного #-выражения (%1) отличается от ожидаемого типа значения (%2).'"), ТипЗнч(Результат), ОписаниеТипа),
					НСтр("ru='Реквизиту присвоено вычисленное значение'"),
					Контекст.ИмяКолонки
				);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	
	Возврат Результат; 
КонецФункции

&НаСервереБезКонтекста
Функция ПреобразоватьТипВСтроку(знач ТипРезультата)
	Если ТипРезультата = Тип("Строка") Тогда
		Возврат "Строка";
	ИначеЕсли ТипРезультата = Тип("Число") Тогда
		Возврат "Число";
	ИначеЕсли ТипРезультата = Тип("Дата") Тогда
		Возврат "Дата";
	ИначеЕсли ТипРезультата = Тип("Булево") Тогда
		Возврат "Булево";
	ИначеЕсли ТипРезультата = Тип("Неопределено") Тогда
		Возврат "Неопределено";
	ИначеЕсли ТипРезультата = Тип("NULL") Тогда
		Возврат "NULL";
	ИначеЕсли ТипРезультата = Тип("Тип") Тогда
		Возврат "Тип";
	//ИначеЕсли ТипРезультата = Тип("ВидДвиженияНакопления") Тогда
	Иначе// ссылочный простой тип 
		мдОбъекта = Метаданные.НайтиПоТипу(ТипРезультата);
		Если мдОбъекта <> Неопределено Тогда
			Возврат мдОбъекта.ПолноеИмя();
		Иначе
			Возврат Строка(ТипРезультата); 
		КонецЕсли; 
	КонецЕсли;
	
	Возврат ТипРезультата; 
КонецФункции
 

&НаСервере
Функция НайтиЗначениеСсылочногоТипа(Результат, знач ПреобразуемоеЗначение, знач ТипРезультата, знач РеквизитПоискаДляСсылочногоТипа, ДанныеОшибки, Контекст)
	ДанныеОшибки = Неопределено;
	
	Если ТипЗнч(ТипРезультата) = Тип("Строка") Тогда
		ПолноеИмяТипаРезультата = ТипРезультата;
		мдСсылки = Метаданные.НайтиПоПолномуИмени(ПолноеИмяТипаРезультата);
	Иначе
		МассивТипов = Новый Массив(1);
		МассивТипов[0] = ТипРезультата; 
		ОписаниеТипаРезультата = Новый ОписаниеТипов(МассивТипов);
		ПустоеЗначениеТипаРезультата = ОписаниеТипаРезультата.ПривестиЗначение(Неопределено);
		мдСсылки = ПустоеЗначениеТипаРезультата.Метаданные();
		
		ПолноеИмяТипаРезультата = мдСсылки.ПолноеИмя();
	КонецЕсли; 
	
	// точка в полном имени метаданного есть всегда.
	ПозицияТочки = СтрНайти(ПолноеИмяТипаРезультата,".");
	ИмяТипа = Лев(ПолноеИмяТипаРезультата, ПозицияТочки-1);
		
	Если ПустаяСтрока(РеквизитПоискаДляСсылочногоТипа) Тогда
		РеквизитПоискаДляСсылочногоТипа = ПолучитьРеквизитПоискаПоУмолчанию(ИмяТипа);
	КонецЕсли;
	
	Если ПустаяСтрока(РеквизитПоискаДляСсылочногоТипа) Тогда
		Данныеошибки = Новый Структура("Текст, Код", 
			СтрШаблон(
				НСтр("ru='Не задан ни реквизит поиска для колонки, ни способ поиска по умолчанию для типа ""%1"".'"),
				ИмяТипа
			),
			"Е67"
		);
			
		Возврат Ложь; 
	КонецЕсли;
	
	Отбор = Новый Соответствие;
	Отбор.Вставить(РеквизитПоискаДляСсылочногоТипа, ПреобразуемоеЗначение);
	Возврат НайтиЗначениеСсылочногоТипаПоОтбору(Результат, ПолноеИмяТипаРезультата, мдСсылки, Отбор, ДанныеОшибки, Контекст);
КонецФункции

&НаСервере
Функция НайтиЗначениеСсылочногоТипаПоОтбору(Результат, ПолноеИмяТипаРезультата, мдСсылки, Отбор, ДанныеОшибки, Контекст)
	ДанныеОшибки = Неопределено;
	Запрос = Новый Запрос;
	ИмяТипа = СтрРазделить(ПолноеИмяТипаРезультата,".")[0];
	УсловияПоиска = Новый Массив;
	КолонкиПоиска = Новый Массив;
	МассивЗначенийПараметров = Новый Массив;
	
	Для каждого ЭлементОтбора Из Отбор Цикл
		Если Лев(ЭлементОтбора.Ключ,1)="$" Тогда
			Если СтрСравнить(ЭлементОтбора.Ключ,"$id")=0 Тогда
				Результат = ПолучитьСсылкуПоID(Объект.Источник, ПолноеИмяТипаРезультата, ЭлементОтбора.Значение, ДанныеОшибки);
				Если ДанныеОшибки <> Неопределено Тогда
					Возврат Ложь; 
				КонецЕсли; 
				Если Результат = Неопределено Тогда
					Данныеошибки = Новый Структура("Текст, Код, Пропуск", 
						СтрШаблон(
							НСтр("ru='Не найдена ссылка типа ""%1"" по идентификатору источника (ID) ""%2"".'"),
							ПолноеИмяТипаРезультата, ЭлементОтбора.Значение
						),
						"Е68",
						"КолонкаПропущенаИлиОстановка"
					);
					Возврат Ложь;
				Иначе
					Возврат Истина; 
				КонецЕсли; 
			ИначеЕсли СтрСравнить(ЭлементОтбора.Ключ,"$ref")=0 Тогда
				МенеджерОбъекта = Неопределено;
				ПолучитьМетаданныеИМенеджерОбъекта(ПолноеИмяТипаРезультата,,, МенеджерОбъекта, ДанныеОшибки,, Ложь);
				Если ДанныеОшибки = Неопределено Тогда
					Результат = ПолучитьСсылкуПоRef(МенеджерОбъекта, ЭлементОтбора.Значение, ДанныеОшибки);
				КонецЕсли; 
				Если ДанныеОшибки <> Неопределено Тогда
					ДанныеОшибки.Вставить("Пропуск", "КолонкаПропущенаИлиОстановка");
					Возврат Ложь; 
				КонецЕсли; 
				
				Если БитаяСсылка(Результат) Тогда
					ТекстСообщения = СтрШаблон(
						НСтр("ru='Cсылка типа ""%1"" c UID ""%2"" является ""битой"".'"),
						ПолноеИмяТипаРезультата, ЭлементОтбора.Значение
					);

					Если Объект.РазрешитьСозданиеБитыхСсылок Тогда
						ДобавитьСобытиеВПротоколСервер(
							"Предупреждение",
							"Е72",
							Контекст.ДанныеФайла.ИмяОбъекта,
							Контекст.ДанныеФайла.ИмяТЧ,
							Контекст.НомерСтроки,
							ТекстСообщения,
							НСтр("ru='Значение реквизита заполнено ""битой ссылкой""'"),
							Контекст.ИмяКолонки
						);
					Иначе
						ДанныеОшибки = Новый Структура("Текст, Код, Пропуск", 
						    ТекстСообщения,
							"Е71",
							"КолонкаПропущенаИлиОстановка"
						);
						Возврат Ложь; 
					КонецЕсли;
				КонецЕсли; // битая ссылка $ref
				
				Возврат Истина;
			ИначеЕсли СтрСравнить(ЭлементОтбора.Ключ,"$v")=0 Тогда
				//системные перечисления обрабатываются только в головной ф-ии ПреобразоватьЗначение, здесь они не нужны.

				Если не ПолучитьПредопределенноеЗначениеБезопасно(Результат, ПолноеИмяТипаРезультата+"."+ЭлементОтбора.Значение, ДанныеОшибки) Тогда
					ДанныеОшибки.Вставить("Пропуск", "КолонкаПропущенаИлиОстановка");
					Возврат Ложь; 
				КонецЕсли;
				Возврат Истина; 
			Иначе // неизвестный системный реквизит
				Данныеошибки = Новый Структура("Текст, Код, Пропуск", 
				    СтрШаблон(НСтр("ru='Для поиска ссылочного значения ""%1"" указан неизвестный системный реквизит ""%2"".'") , ЭлементОтбора.Значение,ЭлементОтбора.Ключ),
					"Е97",
					"КолонкаПропущенаИлиОстановка"
				);
				Возврат Ложь; 
			КонецЕсли;
		Иначе // имя реквизита не начинается с $ 
			// проверим, есть ли вообще такой реквизит
			мдРеквизит = Неопределено;
			Если не СуществуетРеквизитОбъекта(мдСсылки, ИмяТипа, "", ЭлементОтбора.Ключ, Истина, мдРеквизит) Тогда
				ДанныеОшибки = Новый Структура("Текст, Код, Пропуск", 
				    СтрШаблон(НСтр("ru='Для ссылочного значения ""%1"" отсутствует реквизит поиска ""%2"".'") , ЭлементОтбора.Значение, ЭлементОтбора.Ключ),
					"Е74",
					"КолонкаПропущенаИлиОстановка"
				);
				Возврат Ложь; 
			КонецЕсли; 
			
			// преобразуем значение к правильному типу.
			ОписаниеТипаРеквизита = мдРеквизит.Тип;
			Продолжать = Ложь;
			ПреобразуемоеЗначение = ЭлементОтбора.Значение;
			Если ОписаниеТипаРеквизита.СодержитТип(ТипЗнч(ПреобразуемоеЗначение)) Тогда
				Значение = ПреобразуемоеЗначение;
			ИначеЕсли не ЗначениеЗаполнено(ПреобразуемоеЗначение) Тогда
				Значение = ОписаниеТипаРеквизита.ПривестиЗначение(ПреобразуемоеЗначение);
			Иначе
				Продолжать = Истина;
			КонецЕсли;
			Если Продолжать и ОписаниеТипаРеквизита.СодержитТип(Тип("Дата")) Тогда
				Если ПолучитьДатуИзСтроки(Значение, ПреобразуемоеЗначение) Тогда
					Продолжать = Ложь;
				КонецЕсли; 
			КонецЕсли;
			Если Продолжать и ОписаниеТипаРеквизита.СодержитТип(Тип("Число")) Тогда
				Если ПолучитьЧислоИзСтроки(Значение, ПреобразуемоеЗначение) Тогда
					Продолжать = Ложь;
				КонецЕсли; 
			КонецЕсли;
			Если Продолжать и ОписаниеТипаРеквизита.СодержитТип(Тип("Булево")) Тогда
				Если ПреобразоватьВЗначениеБулево(Значение, ПреобразуемоеЗначение, Неопределено) Тогда
					Продолжать = Ложь;
				КонецЕсли; 
			КонецЕсли;
			Если Продолжать и ОписаниеТипаРеквизита.СодержитТип(Тип("Строка")) Тогда
				Значение = Строка(ПреобразуемоеЗначение);
				Продолжать = Ложь;
			КонецЕсли;
			
			Если Продолжать Тогда
				// преобразование не получилось
				Данныеошибки = Новый Структура("Текст, Код, Пропуск", 
				    СтрШаблон(
						НСтр("ru='Невозможно преобразовать значение поиска ""%1"" в корректный для реквизита поиска ""%2"" тип - ""%3"".'") , 
						ПреобразуемоеЗначение, ЭлементОтбора.Ключ, Строка(ОписаниеТипаРеквизита)),
					"Е75",
					"КолонкаПропущенаИлиОстановка"
				);
				Возврат Ложь; 
			КонецЕсли; 
			
			// Добавим в условие запроса и в параметр
			УсловияПоиска.Добавить("Т."+ЭлементОтбора.Ключ+" = &"+ЭлементОтбора.Ключ);
			КолонкиПоиска.Добавить(ЭлементОтбора.Ключ);
			Запрос.УстановитьПараметр(ЭлементОтбора.Ключ, Значение);
			МассивЗначенийПараметров.Добавить(Значение);
		КонецЕсли; 
	КонецЦикла;
	
	Запрос.Текст = СтрШаблон("ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2 Т.Ссылка ИЗ %1 КАК Т ГДЕ %2",
		ПолноеИмяТипаРезультата,
		СтрСоединить(УсловияПоиска, " И ")
	);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Результат = Выборка.Ссылка;
	Иначе
		Данныеошибки = Новый Структура("Текст, Код, Пропуск", 
		    СтрШаблон(НСтр("ru='Ссылочное значение с типом ""%1"" не найдено по заданным реквизитам поиска ""%2"" равным ""%3"".'"), 
				ПолноеИмяТипаРезультата,
				СтрСоединить(КолонкиПоиска,", "),
				СтрСоединить(МассивЗначенийПараметров, ", ")),
			"Е76",
			"КолонкаПропущенаИлиОстановка"
		);
		Возврат Ложь; 
	КонецЕсли; 
	
	Если Выборка.Следующий() Тогда
		// неоднозначная ссылка
		ТекстСообщения = СтрШаблон(
			НСтр("ru='Ссылка ""%1"" имеет неоднозначное значение - найдено более одного объекта, соответствующего критериям поиска ""%2"" со значениями ""%3"".'"), 
			ПреобразуемоеЗначение, 
			СтрСоединить(КолонкиПоиска,", "),
			СтрСоединить(МассивЗначенийПараметров, ", ")); 
			
		Если Объект.РазрешитьНеоднозначныеСсылки Тогда
			ДобавитьСобытиеВПротоколСервер(
				"Предупреждение",
				"Е77",
				Контекст.ДанныеФайла.ИмяОбъекта,
				Контекст.ДанныеФайла.ИмяТЧ,
				Контекст.НомерСтроки,
				ТекстСообщения,
				НСтр("ru='В качестве ссылки использовано одно из найденных значений'"),
				Контекст.ИмяКолонки
			);
		Иначе
			Данныеошибки = Новый Структура("Текст, Код, Пропуск", 
			    ТекстСообщения,
				"Е98",
				"КолонкаПропущенаИлиОстановка"
			);
			Возврат Ложь; 
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат Истина; 
КонецФункции

&НаСервере
Процедура ВыполнитьДиезЗапрос(Результат, знач Выражение, знач СтрТипПоУмолчанию, ДанныеОшибки, Контекст)
	// TODO реализовать трансляцию #-выражений
	ДанныеОшибки = Неопределено;
	начПозиция = 1;
	Результат = Неопределено;
	позРазделителя = ВыполнитьДиезЗапросРекурсивно(Результат, Выражение, СтрТипПоУмолчанию, ДанныеОшибки, Контекст, 0, начПозиция);
	Если ДанныеОшибки <> Неопределено Тогда
		ДанныеОшибки.Вставить("Пропуск", "КолонкаПропущенаИлиОстановка");
		Возврат; 
	КонецЕсли; 
	
	Если позРазделителя <> 0 Тогда
		ДанныеОшибки = Новый Структура("Текст, Код", 
			СтрШаблон(НСтр("ru='Ошибка разбора #-выражения. Ожидается конец выражения в позиции %1.'"), позРазделителя), 
			"Е105"
		);
	КонецЕсли; 
	
КонецПроцедуры

&НаСервереБезКонтекста
Процедура ПропуститьПустыеСимволы(знач Выражение, Позиция)
	Выражение = Сред(Выражение, Позиция);
	начДлина = СтрДлина(Выражение);
	Выражение = СокрЛ(Выражение);
	Позиция = Позиция + начДлина - СтрДлина(Выражение);
КонецПроцедуры
 

&НаСервере
Функция ВыполнитьДиезЗапросРекурсивно(Результат, Выражение, знач СтрТипПоУмолчанию, ДанныеОшибки, Контекст, знач Уровень = 0, знач начПозиция=1)
	ПропуститьПустыеСимволы(Выражение, начПозиция);
	
	Если Сред(Выражение, начПозиция, 1) <> "#" Тогда
		ДанныеОшибки = Новый Структура("Текст, Код", 
			СтрШаблон(НСтр("ru='Некорректный формат #-выражения (символ %1). Ожидается символ ""#"".'"), начПозиция), 
			"Е78"
		);
		Возврат -1; 
	КонецЕсли;
	
	СоответствиеПараметрЗначение = Новый Соответствие;
	позНачалаПодвыражения = начПозиция+1;
	
	Если ЭтоЭлементарныйТип(СтрТипПоУмолчанию) Тогда
		мдСсылки = Неопределено;
	Иначе
		мдСсылки = Метаданные.НайтиПоПолномуИмени(СтрТипПоУмолчанию);
	КонецЕсли; 
	
	Пока Истина Цикл
		// После "#" следует подвыражение "имя реквизита" = "значение или подвыражение". Такие подвыражения разделяются "&" или "#)" (уровень 1+), либо строка заакнчивается (уровень 0)
		позРазделителя = РаспознатьПодвыражениеПараметрЗначение(Выражение, позНачалаПодвыражения, СоответствиеПараметрЗначение, ДанныеОшибки, Уровень, Контекст, мдСсылки);
		Если ДанныеОшибки <> Неопределено Тогда
			Возврат -1; 
		КонецЕсли;
		
		Если позРазделителя = 0 Тогда
			// строка закончилась
			Если Уровень <> 0 Тогда
				ДанныеОшибки = Новый Структура("Текст, Код", 
					НСтр("ru='Ошибка разбора #-выражения. Ожидаются символы ""#)"" в конце.'"), 
					"Е104"
				);
				Возврат -1; 
			КонецЕсли;
			Прервать;
		Иначе
			Разделитель = Сред(Выражение, позРазделителя, 2);
			Если Разделитель = "#)" Тогда
				// #-подвыражение синтаксически разобрано. Осталось посчитать его значение
				Прервать;
			ИначеЕсли Лев(Разделитель,1) = "&" Тогда
				// подвыражение "Реквизит=значение" разобрано. Ожидается следующее
				позНачалаПодвыражения = позРазделителя + 1;
			Иначе
				ДанныеОшибки = Новый Структура("Текст, Код", 
					СтрШаблон(НСтр("ru='Ошибка разбора #-выражения (символ %1). Неожиданный символ ""%2"".'"), позРазделителя, Лев(Разделитель,1)),
					"Е118"
				);
				Возврат -1; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	
	ПолноеИмяТипаРезультата = СоответствиеПараметрЗначение["$t"];
	
	Если ПолноеИмяТипаРезультата = Неопределено Тогда
		Если ЗначениеЗаполнено(СтрТипПоУмолчанию) Тогда
			// тип простой, поэтому явное указание типа значения необязательно. Получаем его из переданного типа
			ПолноеИмяТипаРезультата = СтрТипПоУмолчанию; 
		КонецЕсли;
	КонецЕсли; 
	
	Если не ЗначениеЗаполнено(ПолноеИмяТипаРезультата) Тогда
		// тип составной или не указан тип по умолчанию. Необходимо явное указание типа значения.
		ДанныеОшибки = Новый Структура("Текст, Код", 
			НСтр("ru='Ошибка разбора #-выражения. Не указан тип значения выражения (параметр ""$t"").'"), 
			"Е108"
		);
		Возврат -1; 
	КонецЕсли;
	
	СоответствиеПараметрЗначение.Удалить("$t");
	
	Если ЭтоЭлементарныйТип(ПолноеИмяТипаРезультата) Тогда
		ТипРезультата = ПолучитьЭлементарныйТипИзСтроки(ПолноеИмяТипаРезультата);
		Если ТипРезультата = Неопределено Тогда
			ДанныеОшибки = Новый Структура("Текст, Код", 
				СтрШаблон(
					НСтр("ru='Ошибка выполнения #-выражения. Неизвестный элементарный тип ""%1"".'"),
					ПолноеИмяТипаРезультата
				), 
				"Е111"
			);
			Возврат -1; 
		КонецЕсли;
		Если ТипРезультата = Тип("Неопределено") Тогда
			Результат = Неопределено;
			Возврат позРазделителя; 
		КонецЕсли; 
		Если СоответствиеПараметрЗначение["$v"]=Неопределено Тогда
			ДанныеОшибки = Новый Структура("Текст, Код", 
				СтрШаблон(
					НСтр("ru='Ошибка выполнения #-выражения. Не указано значение для поля элементарного типа ""%1"".'"),
					Строка(ТипРезультата)
				), 
				"Е109"
			);
			Возврат -1; 
		КонецЕсли;
		ПреобразуемоеЗначение = СоответствиеПараметрЗначение["$v"];
		ЗначениеОтсутствует = Неопределено;
		Результат = ПреобразоватьЗначение(ПреобразуемоеЗначение, ТипРезультата, "", ЗначениеОтсутствует, ДанныеОшибки, Контекст);
		Если ДанныеОшибки <> Неопределено Тогда
			Возврат -1; 
		КонецЕсли;
		Если ЗначениеОтсутствует Тогда
			МасТипов = Новый Массив(1);
			МасТипов[0] = ТипРезультата; 
			ОписаниеТипа = Новый ОписаниеТипов(МасТипов);
			Результат = ОписаниеТипа.ПривестиЗначение(ПреобразуемоеЗначение);
			Возврат позРазделителя; 
		КонецЕсли;
	Иначе
		Если мдСсылки = Неопределено Тогда
			ДанныеОшибки = Новый Структура("Текст, Код", 
				СтрШаблон(
					НСтр("ru='Ошибка выполнения #-выражения. Неизвестный ссылочный тип ""%1"".'"),
					ПолноеИмяТипаРезультата
				), 
				"Е112"
			);
			Возврат -1; 
		КонецЕсли; 
		НайтиЗначениеСсылочногоТипаПоОтбору(Результат, ПолноеИмяТипаРезультата, мдСсылки, СоответствиеПараметрЗначение, ДанныеОшибки, Контекст);
		Если ДанныеОшибки <> Неопределено Тогда
			Возврат -1; 
		КонецЕсли;
	КонецЕсли;
	
	Возврат позРазделителя; 	
	
КонецФункции 


&НаСервере
Функция РаспознатьПодвыражениеПараметрЗначение(Выражение, знач начПозиция, СоответствиеПараметрЗначение, ДанныеОшибки, Уровень, Контекст, мдСсылки)
	// Распознаем подвыражение вида <Параметр>=<Значение>|<#-Выражение>
	// После "#" следует имя реквизита. Если имя системное, оно начинается с "$". Заканчивается имя реквизита символом "="
	ПропуститьПустыеСимволы(Выражение, начПозиция);
	
	позицияРавно = СтрНайти(Выражение,"=", НаправлениеПоиска.СНачала, начПозиция);
	Если позицияРавно = 0 Тогда
		ДанныеОшибки = Новый Структура("Текст, Код", 
			СтрШаблон(НСтр("ru='Ошибка разбора #-выражения. Ожидается символ ""="" начиная с позиции %1.'"), начПозиция+1), 
			"Е101"
		);
		Возврат -1; 
	КонецЕсли;
	
	ИмяРеквизита = СокрП(Сред(Выражение, начПозиция, позицияРавно-начПозиция));
	ИмяРеквизитаНРег = НРег(ИмяРеквизита);
	
	Если ИмяРеквизитаНРег = "$t" или ИмяРеквизитаНРег = "$v" или ИмяРеквизитаНРег = "$ref" или ИмяРеквизитаНРег = "$id" Тогда
		ЭтоСистемныйРеквизит = Истина;
	ИначеЕсли СтрокаЯвляетсяИдентификатором(ИмяРеквизита,"_", "") Тогда
		ЭтоСистемныйРеквизит = Ложь;
	ИначеЕсли СтрНачинаетсяС(ИмяРеквизита, "$") Тогда 
		ДанныеОшибки = Новый Структура("Текст, Код", 
			СтрШаблон(НСтр("ru='Ошибка разбора #-выражения. Некорректное имя системного реквизита - ""%1"" (символ %2).'"), ИмяРеквизита, начПозиция), 
			"Е102"
		);
		Возврат -1; 
	Иначе
		ДанныеОшибки = Новый Структура("Текст, Код", 
			СтрШаблон(НСтр("ru='Ошибка разбора #-выражения (символ %1). Имя реквизита может содержать только буквы, цифры и символы подчеркивания, и начинаться не с цифры.'"), начПозиция), 
			"Е103"
		);
		Возврат -1; 
	КонецЕсли;
	
	Результат = Неопределено;
	позицияКонец = РазобратьЗначениеПараметра(Результат, Выражение, позицияРавно+1, ИмяРеквизита, ДанныеОшибки, Уровень, Контекст, мдСсылки); // относительно подстроки после символа "="
	Если ДанныеОшибки <> Неопределено Тогда
		Возврат -1; 
	КонецЕсли;
	
	СоответствиеПараметрЗначение.Вставить(ИмяРеквизита, Результат);	
	
	Если ИмяРеквизитаНРег="$t" Тогда
		Если ЭтоЭлементарныйТип(Результат) Тогда
			мдСсылки = Неопределено;
		Иначе
			мдСсылки = Метаданные.НайтиПоПолномуИмени(Результат);
		КонецЕсли; 
	КонецЕсли; 
	
	Если позицияКонец > 0 Тогда
		Разделитель = Сред(Выражение, позицияКонец, 2);
		Если Лев(Разделитель,1) = "&" или Разделитель = "#)" Тогда
			Возврат позицияКонец;
		Иначе
			ДанныеОшибки = Новый Структура("Текст, Код", 
				СтрШаблон(
					НСтр("ru='Ошибка разбора #-выражения. После значения параметра ожидается разделитель параметров ""&"" или окончание подвыражения ""#)"" (символ %1).'"), 
					позицияКонец), 
				"Е113"
			);
			Возврат -1; 
		КонецЕсли;
	Иначе
		Возврат 0; 
	КонецЕсли; 

КонецФункции

&НаСервере
Функция РазобратьЗначениеПараметра(Результат, Выражение, знач начПозиция, ИмяРеквизита, ДанныеОшибки, Уровень, Контекст, мдСсылки)
	ПропуститьПустыеСимволы(Выражение, начПозиция);
	Начало2 = Сред(Выражение, начПозиция, 2);	
	
	// определяем СтрТипПоУмолчанию по реквизиту (он не может быть системным)
	мдРеквизит = Неопределено;
	СтрТипПоУмолчанию = "";
	Если мдСсылки <> Неопределено и Лев(ИмяРеквизита,1) <> "$" Тогда
		ИмяТипа = СтрРазделить(мдСсылки.ПолноеИмя(),".")[0]; 
		Если СуществуетРеквизитОбъекта(мдСсылки, ИмяТипа, "", ИмяРеквизита, Истина, мдРеквизит) Тогда
			МасТипов = мдРеквизит.Тип.Типы();
			Если МасТипов.Количество()=1 Тогда
				СтрТипПоУмолчанию = ПреобразоватьТипВСтроку(МасТипов[0]); 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
	Если Начало2 = "(#" Тогда
		Если Лев(ИмяРеквизита,1) = "$" Тогда
			ДанныеОшибки = Новый Структура("Текст, Код", 
				СтрШаблон(
					НСтр("ru='Ошибка разбора #-выражения (символ %1). В качестве значения системного параметра не может выступать #-выражение.'"),
					начПозиция), 
				"Е115"
			);
			Возврат -1; 
		КонецЕсли; 
					
		позОкончаниеПодзапроса = ВыполнитьДиезЗапросРекурсивно(Результат, Выражение, СтрТипПоУмолчанию, ДанныеОшибки, Контекст, Уровень+1, начПозиция+1);
		Если ДанныеОшибки <> Неопределено Тогда
			Возврат -1; 
		КонецЕсли;
		Если позОкончаниеПодзапроса = 0 Тогда
			ДанныеОшибки = Новый Структура("Текст, Код", 
				СтрШаблон(
					НСтр("ru='Ошибка разбора #-выражения. #-подвыражение (уровень %1, начинается с позиции %2 и до конца строки) должно заканчиваться символами ""#)"".'"),
					Уровень+1, начПозиция), 
				"Е114"
			);
			Возврат -1; 
		КонецЕсли;
		
		// пропускаем "#)"
		позОкончаниеПодзапроса = позОкончаниеПодзапроса + 2;
		Если СтрДлина(Выражение) < позОкончаниеПодзапроса Тогда
			Возврат 0;
		Иначе
			Возврат позОкончаниеПодзапроса; 
		КонецЕсли; 
	ИначеЕсли Лев(Начало2,1) = """" Тогда
		// строка в кавычках
		позПослеЗначения = РазобратьЗначениеПараметраДиезВыражения_СтрокаВКавычках(Результат, Выражение, начПозиция, ДанныеОшибки);
	Иначе
		// строка без кавычек
		позПослеЗначения = РазобратьЗначениеПараметраДиезВыражения_СтрокаБезКавычек(Результат, Выражение, начПозиция);
	КонецЕсли; 
	
	Если ДанныеОшибки <> Неопределено Тогда
		Возврат -1; 
	КонецЕсли;

	// если ссылочный тип и не #-выражение, ищем по реквизиту поиска по умолчанию
	Если ЗначениеЗаполнено(СтрТипПоУмолчанию) и не ЭтоЭлементарныйТип(СтрТипПоУмолчанию) Тогда
		
		НайтиЗначениеСсылочногоТипа(Результат, Результат, СтрТипПоУмолчанию, "", ДанныеОшибки, Контекст);
		Если ДанныеОшибки <> Неопределено Тогда
			Возврат -1; 
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат позПослеЗначения; 
КонецФункции
 
&НаСервере
Функция РазобратьЗначениеПараметраДиезВыражения_СтрокаВКавычках(Результат, Выражение, знач начПозиция, ДанныеОшибки)
	Результат = "";
	
	Если Сред(Выражение, начПозиция,1) <> """" Тогда
		ДанныеОшибки = Новый Структура("Текст, Код", 
			СтрШаблон(
				НСтр("ru='Ошибка разбора #-выражения (символ %1). В строке отсутствует открывающая кавычка.'"),
				начПозиция), 
			"Е117"
		);
		Возврат -1; 
	КонецЕсли; 
	
	Длина = СтрДлина(Выражение);
	текПозиция = начПозиция + 1;
	Пока Истина Цикл
		позКавычки = СтрНайти(Выражение, """", НаправлениеПоиска.СНачала, текПозиция);
		Если позКавычки = 0 Тогда
			ДанныеОшибки = Новый Структура("Текст, Код", 
				СтрШаблон(
					НСтр("ru='Ошибка разбора #-выражения (символ %1). В строке отсутствует закрывающая кавычка.'"),
					начПозиция), 
				"Е116"
			);
			Возврат -1; 
		КонецЕсли;
		Результат = Результат + Сред(Выражение, текПозиция, позКавычки-текПозиция);
		Если позКавычки >= Длина Тогда // последний символ строки
			Возврат 0; 
		КонецЕсли;
		Если Сред(Выражение, позКавычки+1,1) <> """" Тогда
			Возврат позКавычки+1; 
		КонецЕсли; 
		Результат = Результат + """";
		Если позКавычки+1 >= Длина Тогда
			Возврат 0; 
		КонецЕсли; 
		текПозиция = позКавычки + 2;
	КонецЦикла; 	
КонецФункции
 
&НаСервере
Функция РазобратьЗначениеПараметраДиезВыражения_СтрокаБезКавычек(Результат, Выражение, знач начПозиция)
	//Служебные символы -  '&', '#', '=', '(', ')', '"'
	//Начальные и конечные пробелы игнорируются
	//Если строка содержит служебные символы, она заключается в кавычки, а символ кавычек сдваивается.
	
	ПропуститьПустыеСимволы(Выражение, начПозиция);
	
	СтрСлужебныхСимволов = "&#=()""";
	
	МасСтрок = СтрРазделить(Сред(Выражение, начПозиция), СтрСлужебныхСимволов, Истина);
	Количество = МасСтрок.Количество();
	Если Количество = 0 Тогда
		Возврат 0;
	КонецЕсли; 
	
	Результат = МасСтрок[0];
	
	Если Количество = 1 Тогда
		Возврат 0; 
	КонецЕсли; 
	
	Возврат начПозиция + СтрДлина(Результат); 
	//ДлинаСтрСлужебныхСимволов = СтрДлина(СтрСлужебныхСимволов);
	//
	//позСлужебныхСимволов = 0;
	//Для сч=1 По ДлинаСтрСлужебныхСимволов Цикл
	//	позСлужебногоСимвола = СтрНайти(Выражение, Сред(СтрСлужебныхСимволов, сч, 1), НаправлениеПоиска.СНачала, начПозиция);
	//	Если позСлужебногоСимвола > 0 Тогда
	//		Если позСлужебныхСимволов > 0 Тогда
	//			позСлужебныхСимволов = Мин(позСлужебныхСимволов, позСлужебногоСимвола);
	//		Иначе
	//			позСлужебныхСимволов = позСлужебногоСимвола;
	//		КонецЕсли; 
	//	КонецЕсли; 
	//КонецЦикла; 
	//
	//Если позСлужебныхСимволов = 0 Тогда
	//	Результат = Сред(Выражение, начПозиция);
	//Иначе
	//	Результат = Сред(Выражение, начПозиция, позСлужебныхСимволов-начПозиция);
	//КонецЕсли; 
	//
	//Возврат позСлужебныхСимволов; 
КонецФункции

&НаСервереБезКонтекста
Функция ЭтоЭлементарныйТип(СтрТип)
	Возврат СтрНайти(СтрТип, ".") = 0; 
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьЭлементарныйТипИзСтроки(знач ПолноеИмяТипа)
	ПолноеИмяТипа = НРег(ПолноеИмяТипа);
	Если ПолноеИмяТипа="н" или ПолноеИмяТипа="неопределено" Тогда
		Возврат Тип("Неопределено");
	ИначеЕсли ПолноеИмяТипа="0" или ПолноеИмяТипа="null" Тогда
		Возврат Тип("NULL");
	ИначеЕсли ПолноеИмяТипа="д" или ПолноеИмяТипа="дата" Тогда
		Возврат Тип("Дата");
	ИначеЕсли ПолноеИмяТипа="л" или ПолноеИмяТипа="булево" Тогда
		Возврат Тип("Булево");
	ИначеЕсли ПолноеИмяТипа="c" или ПолноеИмяТипа="строка" Тогда
		Возврат Тип("Строка");
	ИначеЕсли ПолноеИмяТипа="ч" или ПолноеИмяТипа="число" Тогда
		Возврат Тип("Число");
	КонецЕсли; 
	
	Возврат Неопределено; 
КонецФункции
 

#КонецОбласти 

#Область Вспомогательные

// Проверяет, является ли строка Стр идентификатором.
// Идентификатор может начинатьсяс русской или английской буквы, а также с любого символа, заданного в переменной СписокРазрешенныхРазделителейС1Символа
// Далее может следовать русская или английская буква, цифра,  а также любые символы, заданные в переменных СписокРазрешенныхРазделителейС1Символа и СписокРазрешенныхРазделителейСо2Символа
// Пустая строка не является идентификатором.
//ПАРАМЕТРЫ
//	Стр:Строка. Строка, проверка которой осуществляется.
//  СписокРазрешенныхРазделителейС1Символа:Строка.
//	СписокРазрешенныхРазделителейС1Символа:Строка.
//
//ВОЗВРАЩАЕТ
//	Булево. Истина - Стр является иднтификатором, иначе Ложь.
Функция СтрокаЯвляетсяИдентификатором(Стр, СписокРазрешенныхРазделителейС1Символа="",СписокРазрешенныхРазделителейСо2Символа="") Экспорт
	ДлинаСтроки = СтрДлина(Стр);
	Если ДлинаСтроки=0 Тогда
		Возврат Ложь; 
	КонецЕсли;
	ПервыйСимволСтроки = КодСимвола(Стр,1);
	Если ЭтоАнглийскаяБуква(ПервыйСимволСтроки) или ЭтоРусскаяБуква(ПервыйСимволСтроки) или Найти(СписокРазрешенныхРазделителейС1Символа,Символ(ПервыйСимволСтроки)) <> 0 Тогда
		;
	Иначе
		Возврат Ложь; 
	КонецЕсли; 
	СписокРазрешенныхРазделителей=СписокРазрешенныхРазделителейСо2Символа+СписокРазрешенныхРазделителейС1Символа;
	Для сч=2 По ДлинаСтроки Цикл
		Симв = КодСимвола(Стр, сч);
		Если ЭтоАнглийскаяБуква(Симв) или ЭтоРусскаяБуква(Симв) или ЭтоЦифра(Симв) или Найти(СписокРазрешенныхРазделителей,Символ(Симв)) <> 0 Тогда
			;
		Иначе
			Возврат Ложь; 
		КонецЕсли; 
	КонецЦикла; 
	Возврат Истина; 
КонецФункции

// Возвращает Истина, если Симв - русская буква (строчная или заглавная)
// Ложь, если Симв не является русской буквой.
Функция ЭтоРусскаяБуква(знач КодСимв) Экспорт
	Если КодСимв = 1025 или КодСимв = 1105 Тогда //Ё или ё
		Возврат Истина; 
	ИначеЕсли КодСимв >= 1040 и КодСимв <= 1103 Тогда 
		Возврат Истина; 
	Иначе
		Возврат Ложь; 
	КонецЕсли;
КонецФункции

// Возвращает Истина, если Симв - английская (латинская) буква (строчная или заглавная)
// Ложь, если Симв не является латинской буквой.
Функция ЭтоАнглийскаяБуква(знач КодСимв) Экспорт
	Если КодСимв >= 97 и КодСимв <= 122 Тогда
		Возврат Истина; 
	ИначеЕсли КодСимв >= 65 и КодСимв <= 90 Тогда 
		Возврат Истина; 
	Иначе
		Возврат Ложь; 
	КонецЕсли;
КонецФункции

// Возвращает Истина, если Симв - цифра (от 0 до 9)
// Ложь, если Симв не является цифрой.
Функция ЭтоЦифра(знач КодСимв) Экспорт
	Если КодСимв >= 48 и КодСимв <= 57 Тогда
		Возврат Истина; 
	Иначе
		Возврат Ложь; 
	КонецЕсли;
КонецФункции

&НаСервере
Процедура ДобавитьСообщениеВЛогИзСтруктурыКонтекст(ДанныеОшибки, КодПоУмолчанию, Контекст)
	ДобавитьСообщениеВЛогИзСтруктуры(
		ДанныеОшибки, 
		КодПоУмолчанию, 
		Контекст.ДанныеФайла, 
		ПолучитьЗначениеСвойстваСтруктуры(Контекст, "НомерСтроки", ""),
		ПолучитьЗначениеСвойстваСтруктуры(Контекст, "ИмяКолонки", ""));
КонецПроцедуры

&НаСервере
Процедура ДобавитьСообщениеВЛогИзСтруктуры(ДанныеОшибки, знач КодОшибки, ДанныеФайла, НомерСтроки="", ИмяКолонки="")
	Если ТипЗнч(ДанныеОшибки) <> Тип("Структура") Тогда
		Возврат; 
	КонецЕсли; 
	
	Код = "";
	Если не ДанныеОшибки.Свойство("Код", Код) Тогда
		Код = КодОшибки;
	КонецЕсли; 
	
	ТекстОшибки = ПолучитьЗначениеСвойстваСтруктуры(ДанныеОшибки, "Текст", "");
	
	Пропуск = ПолучитьЗначениеСвойстваСтруктуры(ДанныеОшибки, "Пропуск", "СтрокаПропущенаИлиОстановка");
	   
	Если СтрСравнить(Пропуск, "Остановка")=0 Тогда
		ОстановкаПоОшибке = Истина; 
	ИначеЕсли СтрСравнить(Пропуск, "ФайлПропущен")=0 Тогда
		ДанныеФайла.ДопСвойства.Вставить("ПропуститьФайл", Истина);
	КонецЕсли; 
	
	
	ДобавитьСобытиеВПротоколСервер(                                                        
		ПолучитьЗначениеСвойстваСтруктуры(ДанныеОшибки, "Тип", "Ошибка"),
		Код,
		ДанныеФайла.ИмяОбъекта,
		ДанныеФайла.ИмяТЧ,
		НомерСтроки,
		ТекстОшибки,
		РезультатПротокол(Пропуск),
		ИмяКолонки);
		
		
КонецПроцедуры

&НаКлиенте
Процедура ДобавитьСобытиеВПротокол(Тип, КодОшибки, Объект = "", ТЧ = "", НомерСтроки = 0, Описание = "", Результат = "")
	НоваяСтрока = ТаблицаПротокол.Добавить();
	НоваяСтрока.Тип         = Тип;
	НоваяСтрока.КодОшибки   = КодОшибки;
	НоваяСтрока.Объект      = Объект;
	НоваяСтрока.ТЧ          = ТЧ;
	НоваяСтрока.НомерСтроки = НомерСтроки;
	НоваяСтрока.Описание    = Описание;
	НоваяСтрока.Результат   = Результат;	
КонецПроцедуры

&НаСервере
Процедура ДобавитьСобытиеВПротоколСервер(Тип, КодОшибки, Объект = "", ТЧ = "", НомерСтроки = 0, Описание = "", Результат = "", Колонка = "")
	НоваяСтрока = ТаблицаПротокол.Добавить();
	НоваяСтрока.Тип         = Тип;
	НоваяСтрока.КодОшибки   = КодОшибки;
	НоваяСтрока.Объект      = Объект;
	НоваяСтрока.ТЧ          = ТЧ;
	НоваяСтрока.НомерСтроки = НомерСтроки;
	НоваяСтрока.Описание    = Описание;
	НоваяСтрока.Результат   = Результат;	
	НоваяСтрока.Колонка   	= Колонка;	
	
	//всего 29 числовых кодов ошибок
	
КонецПроцедуры

// Безопасно получает значение свойства структуры.
// Если в структуре отсутствует указанное свойство, возвращается значение по умолчанию.
//ПАРАМЕТРЫ
//	Структ:Структура. Структура, из которого получаем значение свойства.
//	ИмяСвойства:Строка. Имя свойства структуры Структура для получения.
//  ЗначениеПоУмолчанию:Произвольный. Значение, возвращаемое функцией при отсутствии свойства ИмяСвойства в структуре Структ.
//ВОЗВРАЩАЕТ
//	Произвольный. Полученное значение свойства или значение по умолчанию, если свойство отсутствует.
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьЗначениеСвойстваСтруктуры(Структ,ИмяСвойства, ЗначениеПоУмолчанию = Неопределено)
	Если Структ = Неопределено Тогда
		Возврат ЗначениеПоУмолчанию; 
	КонецЕсли; 
	
	ЗначениеСвойства = Неопределено;
	Если Структ.Свойство(ИмяСвойства,ЗначениеСвойства) Тогда
		Возврат ЗначениеСвойства;
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли; 
КонецФункции

// Проверяет, является ли ссылка "битой", т.е. отсутствует ли в БД объект с указанной ссылкой.
//
//ПАРАМЕТРЫ
//	СсылкаНаОбъект:Ссылка. Ссылка, проверяемая на "битость".
//ВОЗВРАЩАЕТ
//	Булево. Истина, если ссылка является "битой".
Функция БитаяСсылка(СсылкаНаОбъект) Экспорт
	Запрос=Новый Запрос;
	Запрос.Текст=
	"ВЫБРАТЬ
	|	Т.Ссылка
	|ИЗ
	|	Справочник.Банки КАК Т
	|ГДЕ
	|	Т.Ссылка = &Ссылка";
	
	Запрос.Текст=СтрЗаменить(Запрос.Текст,"Справочник.Банки КАК Т",СсылкаНаОбъект.Метаданные().ПолноеИмя()+" КАК Т");
	Запрос.УстановитьПараметр("Ссылка",СсылкаНаОбъект);
	Возврат Запрос.Выполнить().Пустой();
КонецФункции

&НаСервере
Процедура ОшибкаРазбораЛистаОписания(стрДанныеФайла, Знач ИндексСтроки, знач КодОшибки, знач Сообщение)
	
	ДобавитьСобытиеВПротоколСервер(
		"Ошибка",
		КодОшибки,
		стрДанныеФайла.ИмяОбъекта,
		стрДанныеФайла.ИмяТЧ,
		ИндексСтроки+стрДанныеФайла.ОписаниеНомерПервойСтроки,
		Сообщение,
		?(не ОстановкаПоОшибке,
			РезультатПротокол().КолонкаПропущена,
			РезультатПротокол().Остановка
		)
	);
	
КонецПроцедуры


&НаСервере
Функция РезультатПротокол(Ключ = Неопределено)
	
	Перем РезультатПротокол;
	
	РезультатПротокол = Новый Структура;
	РезультатПротокол.Вставить("Остановка", "Обработка остановлена");
	//РезультатПротокол.Вставить("ОбъектНеСоздан", "Объект не создан");
	//РезультатПротокол.Вставить("ОбъектНеОбновлен", "Объект не обновлен");
	//РезультатПротокол.Вставить("ОбъектНеНайден", "Объект не найден");
	РезультатПротокол.Вставить("ФайлПропущен", НСтр("ru='Файл пропущен'"));
	РезультатПротокол.Вставить("КолонкаПропущена", НСтр("ru='Колонка пропущена'")); 
	РезультатПротокол.Вставить("СтрокаПропущена", НСтр("ru='Строка пропущена'"));
	РезультатПротокол.Вставить("СтрокаПропущена", НСтр("ru='Строка пропущена'"));
	РезультатПротокол.Вставить("ТЧОбъектаПропущена", НСтр("ru='Табличная часть объекта пропущена'"));
	РезультатПротокол.Вставить("НЗПропущен", НСтр("ru='Набор записей c отбором по полям отбора, пропущен'"));



	Если ОстановкаПоОшибке Тогда
		РезультатПротокол.Вставить("ФайлПропущенИлиОстановка", РезультатПротокол.Остановка);
		РезультатПротокол.Вставить("СтрокаПропущенаИлиОстановка", РезультатПротокол.Остановка);
		РезультатПротокол.Вставить("КолонкаПропущенаИлиОстановка", РезультатПротокол.Остановка); 
		РезультатПротокол.Вставить("ТЧОбъектаПропущенаИлиОстановка", РезультатПротокол.Остановка);
		РезультатПротокол.Вставить("НЗПропущенИлиОстановка", РезультатПротокол.Остановка);
	Иначе
		РезультатПротокол.Вставить("ФайлПропущенИлиОстановка", РезультатПротокол.ФайлПропущен);
		РезультатПротокол.Вставить("СтрокаПропущенаИлиОстановка", РезультатПротокол.СтрокаПропущена);
		РезультатПротокол.Вставить("КолонкаПропущенаИлиОстановка", РезультатПротокол.КолонкаПропущена); 
		РезультатПротокол.Вставить("ТЧОбъектаПропущенаИлиОстановка", РезультатПротокол.ТЧОбъектаПропущена);
		РезультатПротокол.Вставить("НЗПропущенИлиОстановка", РезультатПротокол.НЗПропущен);
	КонецЕсли; 
	
	Если Ключ = Неопределено Тогда
		Возврат РезультатПротокол;
	Иначе
		Возврат РезультатПротокол[Ключ]; 
	КонецЕсли; 
КонецФункции
	
#КонецОбласти 
